<!DOCTYPE html>
<html class="wf-opensans-i3-active wf-opensans-i4-active wf-opensans-i6-active wf-opensans-i7-active wf-opensans-i8-active wf-opensans-n3-active wf-opensans-n4-active wf-opensans-n6-active wf-opensans-n7-active wf-opensans-n8-active wf-active wf-opensanscondensed-i3-active wf-opensanscondensed-n3-active wf-opensanscondensed-n7-active"><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252">
<link rel="icon" href="http://15462.courses.cs.cmu.edu/fall2016/assets/images/favicon/dragon.png" type="image/png">
<title>Scotty3D Developer Manual : Computer Graphics : 15-462/662 Fall 2016</title>

<link rel="stylesheet" href="DeveloperManual_files/l_002.css" media="all"><script src="DeveloperManual_files/open-sansn3i3n4i4n6i6n7i7n8i8.js"></script>
<link rel="stylesheet" href="DeveloperManual_files/l.css" media="all"><script src="DeveloperManual_files/open-sans-condensedn3i3n7.js"></script>

<script src="DeveloperManual_files/jquery_002.js"></script>
<script src="DeveloperManual_files/jquery.js"></script>
<script src="DeveloperManual_files/jquery_003.js"></script>

<script src="DeveloperManual_files/codemirror.js"></script>
<script src="DeveloperManual_files/markdown.js"></script>

<script type="text/javascript" src="DeveloperManual_files/MathJax.js">
</script>

<script type="text/x-mathjax-config;executed=true">
MathJax.Hub.Config({
  skipStartupTypeset: true,
  showProcessingMessages: false,
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>


<link rel="stylesheet" type="text/css" href="DeveloperManual_files/codemirror.css">

<script src="DeveloperManual_files/prettify.js"></script>
<link rel="stylesheet" type="text/css" href="DeveloperManual_files/prettify.css">

<!-- NOTE(kayvonf): place at end to override 3rd party tools -->
<link rel="stylesheet" type="text/css" href="DeveloperManual_files/main.css">

<script type="text/javascript">
var edit_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_edit_comment";
var delete_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_delete_comment";
var archive_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_archive_comment";
var add_private_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_private_comment";
var add_instructor_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_instructor_comment";
var add_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_comment";
var comment_vote_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_comment_vote";
var toggle_subscribe_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_toggle_subscribe";
var prompt_students_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_prompt_students";
var keep_alive_url = "http://15462.courses.cs.cmu.edu/fall2016/keep_alive";
</script>

<script type="text/javascript" src="DeveloperManual_files/main.js"></script>
<script type="text/javascript" src="DeveloperManual_files/comments.js"></script>

<style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax.MathJax_FullWidth {text-align: center; display: table-cell!important; width: 10000em!important}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax_LineBox {display: table!important}
.MathJax_LineBox span {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none; padding: 0; border: 0; margin: 0}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Main; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.0') format('opentype')}
@font-face {font-family: MathJax_Main; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.0') format('opentype'); font-weight: bold}
@font-face {font-family: MathJax_Main; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.0') format('opentype'); font-style: italic}
@font-face {font-family: MathJax_Math; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.0') format('opentype'); font-style: italic}
@font-face {font-family: MathJax_Caligraphic; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.0') format('opentype')}
@font-face {font-family: MathJax_Size1; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.0') format('opentype')}
@font-face {font-family: MathJax_Size2; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.0') format('opentype')}
@font-face {font-family: MathJax_Size3; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.0') format('opentype')}
@font-face {font-family: MathJax_Size4; src: url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.0') format('woff'), url('http://cdn.mathjax.org/mathjax/2.7-latest/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.0') format('opentype')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px none; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

<div id="modal_overlay"></div>

<div class="main_container">

<div class="topbar">
<div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/home">[Home]</a></div>
<div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/courseinfo">[Info]</a></div>
<div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/newsfeed">[Feed]</a></div>
<div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/lectures">[Lectures]</a></div>
<div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/exercises">[Quizzes]</a></div>
<!-- <div class="topbar_left"><a href="http://15462.courses.cs.cmu.edu/fall2016/projects">[Projects]</a></div> -->



<div class="topbar_right">

<a href="http://15462.courses.cs.cmu.edu/fall2016/users/login">[Login]</a>

</div>

</div>

<div class="content_container">

<!-- end of header -->






<div class="article_container">

<div class="common_title title">Scotty3D Developer Manual</div>

<hr size="1">


<div class="markdown article-content">
<p><img src="DeveloperManual_files/Scotty3DLogo.svg" alt="Scotty3DLogo"></p>

<h2>Overview</h2>

<p>This document describes the internal data structures and algorithms 
that comprise the Scotty3D codebase, focusing mainly on core 
functionality (e.g., meshing and ray tracing).  Limited documentation of
 the graphical user interface (GUI) is available via comments in the 
source itself (though this information is not needed for assignments).</p>

<h2>Geometric Data Structures</h2>

<p>Scotty3D uses a variety of geometric data structures, depending on 
the task.  Some operations (e.g., ray tracing) use a simple list of 
triangles that can be compactly encoded and efficiently cached.  For 
more sophisticated geometric tasks like mesh editing and sampling, a 
simple triangle list is no longer sufficient (or leads to unnecessarily 
poor asymptotic performance).  Most actions in MeshEdit mode therefore 
use a topological data structure called a <em>halfedge mesh</em> (also known as a _doubly-connected edge list), which provides a good tradeoff between simplicity and sophistication.</p>

<h3>The Halfedge Data Structure</h3>

<p>The basic idea behind the halfedge data structure is that, in 
addition to the usual vertices, edges, and faces that make up a 
polygonal mesh, we also have an entity called a <em>halfedge</em> that 
acts like "glue" connecting the different elements.  It is this glue 
that allow us to easily "navigate" the mesh, i.e., easily access mesh 
elements adjacent to a given element.</p>

<p><img src="DeveloperManual_files/halfedgePointers.png" alt="halfedgePointers" height="216" width="382"></p>

<p>In particular, there are two halfedges associated with each edge (see
 picture above).  For an edge connecting two vertices i and j, one of 
its halfedges points from i to j; the other one points from j to i.  In 
other words, we say that the two halfedges are <em>oppositely oriented</em>.
  On of the halfedges is associated with the face to the "left" of the 
edge; the other is associated with the face to the "right."  Each 
halfedge knows about the opposite halfedge, which we call its <em>twin</em>.  It also knows about the <em>next</em> halfedge around its face, as well as its associated edge, face, and vertex.</p>

<p>In contrast, the standard mesh elements (vertices, edges, and faces) know only about <em>one</em> of their halfedges.  In particular:</p>

<ul>
<li>a vertex knows about one of its "outgoing" halfedges,</li>
<li>an edge knows about one of its two halfedges, and</li>
<li>a face knows about one of the many halfedges circulating around its interior.</li>
</ul>

<p>In summary, we have the following relationships:</p>

<p></p><center><p></p>

<table>
<thead>
<tr>
  <th>Mesh element</th>
  <th align="center">Pointers</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Vertex</td>
  <td align="center">one halfedge</td>
</tr>
<tr>
  <td>Edge</td>
  <td align="center">one halfedge</td>
</tr>
<tr>
  <td>Face</td>
  <td align="center">one halfedge</td>
</tr>
<tr>
  <td>Halfedge</td>
  <td align="center">twin, next, vertex, edge, face</td>
</tr>
</tbody>
</table>

<p></p></center><p></p>

<p>This list emphasizes that it is really the <strong>halfedges</strong>
 that connect everything up. An easy example is if we want to visit all 
the vertices of a given face.  We can start at the face's halfedge, and 
follow the "next" pointer until we're back at the beginning. A more 
interesting example is visiting all the vertices adjacent to a given 
vertex v. We can start by getting its outgoing halfedge, then its twin, 
then its next halfedge; this final halfedge will also point out of 
vertex v, but it will point <strong>toward</strong> a different vertex than the first halfedge. By repeating this process, we can visit all the neighboring vertices:</p>

<p></p><center>
<img src="DeveloperManual_files/vertexTraversal.png" alt="Walking around a vertex" height="382" width="327">
</center><p></p>

<p>In some sense, a halfedge mesh is kind of like a linked list on 
steroids. For instance, the halfedges around a given face (connected by <code>next</code> pointers) form a sort of "cyclic" linked list, where the tail points back to the head.</p>

<p>A nice consequence of the halfedge representation is that any valid halfedge mesh <strong>must</strong>
 be manifold and orientable.  Scotty3D will therefore only produce 
manifold, oriented meshes as output (and will complain if the input does
 not satisfy these criteria).</p>

<h3>The <code>HalfedgeMesh</code> Class</h3>

<p>The Scotty3D skeleton code already provides a fairly sophisticated implementation of the half edge data structure, in the <code>HalfedgeMesh</code> class (see <code>halfEdgeMesh.h</code> and <code>halfEdgeMesh.cpp</code>).
 Although the detailed implementation may appear a bit complicated, the 
basic interface is not much different from the abstract description 
given above. For instance, suppose we have a face f and want to print 
out the positions of all its vertices. We would write a routine like 
this:</p>

<pre class="prettyprint"><code><span class="kwd">void</span><span class="pln"> printVertexPositions</span><span class="pun">(</span><span class="typ">FaceCIter</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="typ">HalfEdgeCIter</span><span class="pln"> h </span><span class="pun">=</span><span class="pln"> f</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">();</span><span class="pln"> </span><span class="com">// get the first halfedge of the face</span><span class="pln">
  </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">VertexCIter</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">();</span><span class="pln">   </span><span class="com">// get the vertex of the current halfedge</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> v</span><span class="pun">-&gt;</span><span class="pln">position </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">   </span><span class="com">// print the vertex position</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">                 </span><span class="com">// move to the next halfedge around the face</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">h </span><span class="pun">!=</span><span class="pln"> f</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">());</span><span class="pln">    </span><span class="com">// keep going until we're back at the beginning</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Notice that we refer to a face as a <code>FaceCIter</code> rather than just a <code>Face</code>.  You can think of an <code>Iter</code> as a kind of <em>pointer</em>; the letter <code>C</code> indicates that this pointer is "constant", i.e., for this particular algorithm, we will not change the value pointed to by <code>f</code>.  Note that members of an iterator are accessed with an arrow <code>-&gt;</code> rather than a dot <code>.</code>,
 just as with pointers.  (A more in-depth explanation of some of these 
details can be found in the inline documentation.) Similarly, to print 
out the positions of all the neighbors of a given vertex we could write a
 routine like this:</p>

<pre class="prettyprint"><code><span class="kwd">void</span><span class="pln"> printNeighborPositions</span><span class="pun">(</span><span class="typ">VertexCIter</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="typ">HalfEdgeCIter</span><span class="pln"> h </span><span class="pun">=</span><span class="pln"> v</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">();</span><span class="pln">    </span><span class="com">// get one of the outgoing halfedges of the vertex</span><span class="pln">
  </span><span class="kwd">do</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="typ">HalfEdgeCIter</span><span class="pln"> h_twin </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln"> </span><span class="com">// get the vertex of the current halfedge</span><span class="pln">
    </span><span class="typ">VertexCIter</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> h_twin</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">();</span><span class="pln"> </span><span class="com">// vertex is 'source' of the half edge.</span><span class="pln">
                                      </span><span class="com">// so h-&gt;vertex() is v,</span><span class="pln">
                                      </span><span class="com">// whereas h_twin-&gt;vertex() is the neighbor vertex.</span><span class="pln">
    cout </span><span class="pun">&lt;&lt;</span><span class="pln"> v</span><span class="pun">-&gt;</span><span class="pln">position </span><span class="pun">&lt;&lt;</span><span class="pln"> endl</span><span class="pun">;</span><span class="pln">      </span><span class="com">// print the vertex position</span><span class="pln">
    h </span><span class="pun">=</span><span class="pln"> h_twin</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">               </span><span class="com">// move to the next outgoing halfedge of the vertex.</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">while</span><span class="pun">(</span><span class="pln">h </span><span class="pun">!=</span><span class="pln"> v</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">());</span><span class="pln">        </span><span class="com">// keep going until we're back at the beginning</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>To iterate over <strong>all</strong> the vertices in a halfedge mesh, we could write a loop like this:</p>

<pre class="prettyprint"><code><span class="kwd">for</span><span class="pun">(</span><span class="typ">VertexCIter</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">verticesBegin</span><span class="pun">();</span><span class="pln"> v </span><span class="pun">!=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">verticesEnd</span><span class="pun">();</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  printNeighborPositions</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln"> </span><span class="com">// do something interesting here</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Internally, the lists of vertices, edges, faces, and halfedges are stored as <strong>linked lists</strong>, which allows us to easily add or delete elements to our mesh.  For instance, to add a new vertex we can write</p>

<pre class="prettyprint"><code><span class="typ">VertexIter</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">newVertex</span><span class="pun">();</span></code></pre>

<p>Likewise, to delete a vertex we can write</p>

<pre class="prettyprint"><code><span class="pln">mesh</span><span class="pun">.</span><span class="pln">deleteVertex</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span></code></pre>

<p>Note, however, that one should be <strong>very, very careful</strong>
 when adding or deleting mesh elements. New mesh elements must be 
properly linked to the mesh -- for instance, this new vertex must be 
pointed to one of its associated halfedges by writing something like</p>

<pre class="prettyprint"><code><span class="pln">v</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h</span><span class="pun">;</span></code></pre>

<p>Likewise, if we delete a mesh element, we must be certain that no 
existing elements still point to it; the halfedge data structure does 
not take care of these relationships for you automatically. In fact, 
that is exactly the point of this assignment: to get some practice 
directly manipulating the halfedge data structure.  Being able to 
perform these low-level manipulations will enable you to write useful 
and interesting mesh code far beyond the basic operations in this 
assignment.</p>

<p>Finally, the <strong>boundary</strong> of the surface (e.g., the 
ankles and waist of a pair of pants) requires special care in our 
halfedge implementation. At first glance, it would seem that the routine
 <code>printNeighborPositions()</code> above might break if the vertex <code>v</code> is on the boundary, because at some point we worry that we have no <code>twin()</code>
 element to visit. Fortunately, our implementation has been designed to 
avoid this kind of catastrophe. In particular, rather than having an 
actual hole in the mesh, we create a "virtual" boundary face whose edges
 are all the edges of the boundary loop. This way, we can iterate over 
boundary elements just like any other mesh element. If we ever need to 
check whether an element is on the boundary, we have the methods.</p>

<pre class="prettyprint"><code><span class="typ">Vertex</span><span class="pun">::</span><span class="pln">isBoundary</span><span class="pun">()</span><span class="pln">
</span><span class="typ">Edge</span><span class="pun">::</span><span class="pln">isBoundary</span><span class="pun">()</span><span class="pln">
</span><span class="typ">Face</span><span class="pun">::</span><span class="pln">isBoundary</span><span class="pun">()</span><span class="pln">
</span><span class="typ">Halfedge</span><span class="pun">::</span><span class="pln">isBoundary</span><span class="pun">()</span></code></pre>

<p>These methods return true if and only if the element is contained in 
the domain boundary. Additionally, we store an explicit list of boundary
 faces, which we can iterate over like any other type of mesh element:</p>

<pre class="prettyprint"><code><span class="kwd">for</span><span class="pun">(</span><span class="typ">FaceCIter</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">boundariesBegin</span><span class="pun">();</span><span class="pln"> b </span><span class="pun">!=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">boundariesEnd</span><span class="pun">();</span><span class="pln"> b</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// do something interesting with this boundary loop</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>These virtual faces are not stored in the usual face list, i.e., they
 will not show up when iterating over faces.  The figure below should 
help to further explain the behavior of <code>HalfedgeMesh</code> for surfaces with boundary:</p>

<p><img src="DeveloperManual_files/boundaryConventions.png" alt="Boundary conventions" height="375" width="396"></p>

<p>Dark blue regions indicate interior faces, whereas light blue regions
 indicate virtual boundary faces.  A vertex, edge, or halfedge is 
considered to be part of the boundary if it is contained <em>entirely</em>
 in a boundary face.  For instance, in the figure above the region b is a
 virtual boundary face, which means that vertex v', edge e', and 
halfedge h' are all part of the boundary; their <code>isBoundary()</code>
 methods will return true.  In contrast, vertex v, edge e, face f, and 
halfedge h are not part of the boundary, and their isBoundary() methods 
will return false.  Notice also that the boundary face b is a polygon 
with 12 edges.</p>

<p><em>Note:</em> <em>the edge degree and face degree of a boundary vertex is not the same!</em>  Notice, for instance, that vertex v' is contained in three edges but only two interior faces.  By convention, <code>Vertex::degree()</code>
 returns the face degree, not the edge degree.  The edge degree can be 
computed by finding the face degree, and adding 1 if the vertex is a 
boundary vertex.</p>

<p>Please refer to the inline comments for further details about the <code>HalfedgeMesh</code> data structure.</p>

<h3>Tutorial: Local Mesh Operations</h3>

<p>Many of the actions that need to be implemented in the MeshEdit mode 
are local mesh operations (like edge collapse, face bevel, etc.).  Here 
we provide a step-by-step guide to implementing a simplied version of 
the <em>EdgeFlip</em> operation for a pair of triangles---the final version, however, must be implemented for general polygons (i.e., any <span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax" id="MathJax-Element-1-Frame" tabindex="0" style="position: relative;" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/math&gt;" role="presentation"><nobr aria-hidden="true"><span class="math" id="MathJax-Span-1" style="width: 0.773em; display: inline-block;"><span style="display: inline-block; position: relative; width: 0.605em; height: 0px; font-size: 124%;"><span style="position: absolute; clip: rect(1.812em, 1000.59em, 2.595em, -1000em); top: -2.419em; left: 0em;"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">n</span></span><span style="display: inline-block; width: 0px; height: 2.419em;"></span></span></span><span style="display: inline-block; overflow: hidden; vertical-align: -0.082em; border-left: 0px solid; width: 0px; height: 0.698em;"></span></span></nobr><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">n</script>-gon).  The basic strategy for implementing the other local operations is quite similar to the procedure outlined below.  <strong>Note:</strong> if you're not familiar with C++, you should definitely take a moment to learn about the <a href="http://en.cppreference.com/w/cpp/container/vector">standard library class</a> <code>std::vector</code>, especially the method <code>push_back()</code>, which will make it easy to accumulate a list of pointers as you walk around a polygon, vertex, etc.</p>

<p>A good recipe for ensuring that all pointers are still valid after a local remeshing operation is:</p>

<ol>
<li>Draw a picture of all the elements (vertices, edges, faces, 
halfedges) that will be needed from the original mesh, and all the 
elements that should appear in the modified mesh.</li>
<li>Allocate any new elements that are needed in the modified mesh, but do not appear in the original mesh.</li>
<li>For every element in the "modified" picture, set <strong>all</strong> of its pointers -- even if they didn't change. For instance, for each halfedge, make sure to set <code>next</code>, <code>twin</code>, <code>vertex</code>, <code>edge</code>, and <code>face</code> to the correct values in the new (modified) picture. For each vertex, make sure to set its <code>halfedge</code> pointer.  Etc. A convenience method <code>Halfedge::setNeighbors()</code> has been created for this purpose.</li>
<li>Deallocate any elements that are no longer used in the modified mesh, which can be done by calling <code>HalfedgeMesh::deleteVertex()</code>, <code>HalfedgeMesh::deleteEdge()</code>, etc.</li>
</ol>

<p>The reason for setting all the pointers (and not just the ones that 
changed) is that it is very easy to miss a pointer, causing your code to
 crash. Once the code is working, you can remove these unnecessary 
assignments if you wish -- but remember that <a href="http://c2.com/cgi/wiki?PrematureOptimization">premature optimization is the root of all evil</a></p>

<p>We now consider the case of a triangle-triangle edge flip.</p>

<h4>PHASE 0: Draw a Diagram</h4>

<p>Suppose we have a pair of triangles (a,b,c) and (c,b,d). After 
flipping the edge (b,c), we should now have triangles (a,d,c) and 
(a,b,d).  A good first step for implementing any local mesh operation is
 to draw a diagram that clearly labels all elements affected by the 
operation:</p>

<p></p><center>
<img src="DeveloperManual_files/edgeFlipBeforeAfter.png" alt="Edge flip before and after" height="225" width="673">
</center><p></p>

<p>Here we have drawn a diagram of the region around the edge both 
before and after the edge operation (in this case, "flip"), labeling 
each type of element (halfedge, vertex, edge, and face) from zero to the
 number of elements.  It is important to include every element affected 
by the operation, thinking very carefully about which elements will be 
affected.  If elements are omitted during this phase, everything will 
break---even if the code written in the two phases is correct!  In this 
example, for instance, we need to remember to include the halfedges 
"outside" the neighborhood, since their "twin" pointers will be 
affected.</p>

<h4>PHASE I: Collect elements</h4>

<p>Once you've drawn your diagram, simply collect all the elements from 
the "before" picture. Give them the same names as in your diagram, so 
that you can debug your code by comparing with the picture.</p>

<pre class="prettyprint"><code><span class="com">// HALFEDGES</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h0 </span><span class="pun">=</span><span class="pln"> e0</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h1 </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h2 </span><span class="pun">=</span><span class="pln"> h1</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h3 </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h4 </span><span class="pun">=</span><span class="pln"> h3</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h5 </span><span class="pun">=</span><span class="pln"> h4</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h6 </span><span class="pun">=</span><span class="pln"> h1</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h7 </span><span class="pun">=</span><span class="pln"> h2</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h8 </span><span class="pun">=</span><span class="pln"> h4</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln">
</span><span class="typ">HalfedgeIter</span><span class="pln"> h9 </span><span class="pun">=</span><span class="pln"> h5</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">();</span><span class="pln">

</span><span class="com">// VERTICES</span><span class="pln">
</span><span class="typ">VertexIter</span><span class="pln"> v0 </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">();</span><span class="pln">
</span><span class="typ">VertexIter</span><span class="pln"> v1 </span><span class="pun">=</span><span class="pln"> h3</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">();</span><span class="pln">
</span><span class="com">// ...you fill in the rest!...</span><span class="pln">

</span><span class="com">// EDGES</span><span class="pln">
e1 </span><span class="pun">=</span><span class="pln"> h1</span><span class="pun">-&gt;</span><span class="pln">edge</span><span class="pun">();</span><span class="pln">
e2 </span><span class="pun">=</span><span class="pln"> h2</span><span class="pun">-&gt;</span><span class="pln">edge</span><span class="pun">();</span><span class="pln">
</span><span class="com">// ...you fill in the rest!...</span><span class="pln">

</span><span class="com">// FACES</span><span class="pln">
f0 </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">-&gt;</span><span class="pln">face</span><span class="pun">();</span><span class="pln">
</span><span class="com">// ...you fill in the rest!...</span></code></pre>

<h4>PHASE II: Allocate new elements</h4>

<p>If your edge operation requires new elements, now is the time to 
allocate them. For the edge flip, we don't need any new elements; but 
suppose that for some reason we needed a new vertex v4. At this point we
 would allocate the new vertex via</p>

<pre class="prettyprint"><code><span class="typ">VertexIter</span><span class="pln"> v4 </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">newVertex</span><span class="pun">();</span></code></pre>

<p>(The name used for this new vertex should correspond to the label you
 give it in your "after" picture.)  Likewise, new edges, halfedges, and 
faces can be allocated via the methods <code>mesh.newEdge()</code>, <code>mesh.newHalfedge()</code>, and <code>mesh.newFace()</code>.</p>

<h4>PHASE III: Reassign Elements</h4>

<p>Next, update the pointers for all the mesh elements that are affected
 by the edge operation. Be exhaustive! In other words, go ahead and 
specify every pointer for every element, even if it did not change. Once
 things are working correctly, you can always optimize by removing 
unnecessary assignments. But get it working correctly first! Correctness
 is more important than efficiency.</p>

<pre class="prettyprint"><code><span class="com">// HALFEDGES</span><span class="pln">
h0</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h1</span><span class="pun">;</span><span class="pln">
h0</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h3</span><span class="pun">;</span><span class="pln">
h0</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> v3</span><span class="pun">;</span><span class="pln">
h0</span><span class="pun">-&gt;</span><span class="pln">edge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e0</span><span class="pun">;</span><span class="pln">
h0</span><span class="pun">-&gt;</span><span class="pln">face</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> f0</span><span class="pun">;</span><span class="pln">
h1</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h2</span><span class="pun">;</span><span class="pln">
h1</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h7</span><span class="pun">;</span><span class="pln">
h1</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> v2</span><span class="pun">;</span><span class="pln">
h1</span><span class="pun">-&gt;</span><span class="pln">edge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e2</span><span class="pun">;</span><span class="pln">
h1</span><span class="pun">-&gt;</span><span class="pln">face</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> f0</span><span class="pun">;</span><span class="pln">
</span><span class="com">// ...you fill in the rest!...</span><span class="pln">

</span><span class="com">// ...and don't forget about the "outside" elements!...</span><span class="pln">
h9</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h9</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">();</span><span class="pln"> </span><span class="com">// didn't change, but set it anyway!</span><span class="pln">
h9</span><span class="pun">-&gt;</span><span class="pln">twin</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h4</span><span class="pun">;</span><span class="pln">
h9</span><span class="pun">-&gt;</span><span class="pln">vertex</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> v1</span><span class="pun">;</span><span class="pln">
h9</span><span class="pun">-&gt;</span><span class="pln">edge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e4</span><span class="pun">;</span><span class="pln">
h9</span><span class="pun">-&gt;</span><span class="pln">face</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h9</span><span class="pun">-&gt;</span><span class="pln">face</span><span class="pun">();</span><span class="pln"> </span><span class="com">// didn't change, but set it anyway!</span><span class="pln">

</span><span class="com">// VERTICES</span><span class="pln">
v0</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h2</span><span class="pun">;</span><span class="pln">
v1</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h5</span><span class="pun">;</span><span class="pln">
v2</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h3</span><span class="pun">;</span><span class="pln">
v3</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">;</span><span class="pln">

</span><span class="com">// EDGES</span><span class="pln">
e0</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">;</span><span class="pln"> </span><span class="com">//...you fill in the rest!...</span><span class="pln">

</span><span class="com">// FACES</span><span class="pln">
f0</span><span class="pun">-&gt;</span><span class="pln">halfedge</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> h0</span><span class="pun">;</span><span class="pln"> </span><span class="com">//...you fill in the rest!...</span></code></pre>

<h4>PHASE IV: Delete unused elements</h4>

<p>If your edge operation eliminates elements, now is the best time to 
deallocate them: at this point, you can be sure that they are no longer 
needed. For instance, since we do not need the vertex allocated in PHASE
 II, we could write</p>

<pre class="prettyprint"><code><span class="pln">mesh</span><span class="pun">.</span><span class="pln">deleteVertex</span><span class="pun">(</span><span class="pln"> v4 </span><span class="pun">);</span></code></pre>

<p>You should be careful that this mesh element is not referenced by any
 other element in the mesh. But if your "before" and "after" diagrams 
are correct, that should not be an issue!</p>

<h4>Design considerations</h4>

<p>The basic algorithm outlined above will handle most edge flips, but 
you should also think carefully about possible corner-cases.  You should
 also think about other design issues, like "how much should this 
operation cost?"  For instance, for this simple triangle-triangle edge 
flip it might be reasonable to:</p>

<ul>
<li>Ignore requests to flip boundary edges (i.e., just return immediately if either neighboring face is a boundary loop).</li>
<li>Ignore requests to perform any edge flip that would make the surface non-manifold or otherwise invalidate the mesh.</li>
<li>Not add or delete any elements.  Since there are the same number of 
mesh elements before and after the flip, you should only need to 
reassign pointers.</li>
<li>Perform only a constant amount of work -- the cost of flipping a single edge should <strong>not</strong> be proportional to the size of the mesh!</li>
</ul>

<p>Formally proving that your code is correct in all cases is 
challenging, but at least try to think about what could go wrong in 
degenerate cases (e.g., vertices of low degree, or very small meshes 
like a tetrahedron). The biggest challenge in properly implementing this
 type of local operation is making sure that all the pointers still 
point to the right place in the modified mesh, and will likely be the 
cause of most of your crashes!</p>

<h4>Beveling</h4>

<p>Here we provide some additional detail about the bevel operations and
 their implementation in Scotty3D.  Each bevel operation has two 
components:</p>

<ol>
<li>a method that modifies the <em>connectivity</em> of the mesh, creating new beveled elements, and</li>
<li>a method the updates the <em>geometry</em> of the mesh, insetting and offseting the new vertices according to user input.</li>
</ol>

<p>The methods that update the connectivity are <code>HalfedgeMesh::bevelVertex</code>, <code>halfedgeMesh::bevelEdge</code>, and <code>HalfedgeMesh::bevelFace</code>.  The methods that update geometry are <code>HalfedgeMesh::_bevel_vtx_reposition_with_dist</code>, <code>HalfedgeMesh::_bevel_edge_reposition_with_dist</code>, and <code>HalfedgeMesh::_bevel_fc_reposition_with_dist</code>.  The methods for updating connectivity can be implemented following the general strategy outlined in the tutorial above.</p>

<p>To update the <em>geometry</em> of a beveled element, you are provided with the following data:</p>

<ul>
<li><code>orig</code> - These are the original vertex positions of the mesh element, before any insetting or offseting is applied.</li>
<li><code>hs</code> - These are the halfedges "around" the element currently being beveled.</li>
<li><code>inset</code> - The amount by which the new face should be inset (i.e., "shrunk" or "expanded")</li>
<li><code>shift</code> (faces only) - The amount by which the new face should be offset in the normal direction.</li>
</ul>

<p>More specifically, the array <code>hs</code> stores the following data:</p>

<ul>
<li>For a beveled vertex, <code>hs</code> stores the halfedges pointing <em>from</em> the vertices of the new polygon <em>to</em> the neighbors of the original vertex.</li>
<li>For a beveled edge, <code>hs</code> stores the halfedges pointing <em>from</em> the vertices of the new polygon <em>to</em> the neighbors of the original edge endpoints.</li>
<li>For a beveled face, <code>hs</code> stores the halfedges pointing <em>from</em> the vertices of the new polygon <em>to</em> the vertices of the original polygon.</li>
</ul>

<p>These relationships are illustrated by the following diagram:</p>

<p><img src="DeveloperManual_files/Scotty3DBeveledData.svg" alt="BeveledData"></p>

<p>The basic recipe for updating the vertex positions is then:</p>

<ul>
<li>Iterate over the list of halfedges (<code>hs</code>)</li>
<li>Grab the vertex coordinates that are needed to compute the new, updated vertex coordinates (this could be a mix of values from <code>orig</code>, or the members <code>Vertex::position</code>)</li>
<li>Compute the updated vertex positions using the current values of <code>inset</code> (and possibly <code>shift</code>)</li>
<li>Store the new vertex positions in <code>Vertex::position</code> <em>for the vertices of the new, beveled polygon only</em> (i.e., the positions of any polygon "outside" the dark blue one in the figures above should not be updated)</li>
</ul>

<p>The reason for storing <code>hs</code> and <code>orig</code> in an 
array is that it makes it easy to access positions "to the left" and "to
 the right" of a given vertex.  For instance, suppose we want to figure 
out the offset from the corner of a polygon.  We might want to compute 
some geometric quantity involving the three vertex positions <code>orig[i-1]</code>, <code>orig[i]</code>, and <code>orig[i+1]</code> (as well as <code>inset</code>), then set the new vertex position <code>hs[i]-&gt;vertex()-&gt;position</code> to this new value:</p>

<p><img src="DeveloperManual_files/Scotty3DBevelIndexing.svg" alt="BevelIndexing"></p>

<p>A useful trick here is <em>modular arithmetic</em>: since we really 
have a "loop" of vertices, we want to make sure that indexing the next 
element (+1) and the previous element (-1) properly "wraps around."  
This can be achieved via code like</p>

<pre class="prettyprint"><code><span class="com">// Get the number of vertices in the new polygon</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> N </span><span class="pun">=</span><span class="pln"> hs</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">

</span><span class="com">// Assuming we're looking at vertex i, compute the indices</span><span class="pln">
</span><span class="com">// of the next and previous elements in the list using</span><span class="pln">
</span><span class="com">// modular arithmetic---note that to get the previous index,</span><span class="pln">
</span><span class="com">// we can't just subtract 1 because the mod operation in C++</span><span class="pln">
</span><span class="com">// doesn't behave quite how you might expect for negative</span><span class="pln">
</span><span class="com">// values!</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="pln">N</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> N</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> c </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> N</span><span class="pun">;</span><span class="pln">

</span><span class="com">// Get the actual 3D vertex coordinates at these vertices</span><span class="pln">
</span><span class="typ">Vector3D</span><span class="pln"> pa </span><span class="pun">=</span><span class="pln"> orig</span><span class="pun">[</span><span class="pln">a</span><span class="pun">];</span><span class="pln">
</span><span class="typ">Vector3D</span><span class="pln"> pb </span><span class="pun">=</span><span class="pln"> orig</span><span class="pun">[</span><span class="pln">b</span><span class="pun">];</span><span class="pln">
</span><span class="typ">Vector3D</span><span class="pln"> pc </span><span class="pun">=</span><span class="pln"> orig</span><span class="pun">[</span><span class="pln">c</span><span class="pun">];</span></code></pre>

<p>From here, you will need to compute new coordinates for vertex <code>i</code>, which can be accessed from <code>hes[i]-&gt;vertex()-&gt;position</code>.
  As a "dummy" example (i.e., this is NOT what you should actually do!!)
 this code will set the position of the new vertex to the average of the
 vertices above:</p>

<pre class="prettyprint"><code><span class="pln">hes</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">vertex</span><span class="pun">()-&gt;</span><span class="pln">position </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln"> pa </span><span class="pun">+</span><span class="pln"> pb </span><span class="pun">+</span><span class="pln"> pc </span><span class="pun">)</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="lit">3.</span><span class="pun">;</span><span class="pln"> </span><span class="com">// replace with something that actually makes sense!</span></code></pre>

<p>The only question remaining is: where <em>should</em> you put the beveled vertex? <strong>We will leave this decision up to you.</strong>  This question is one where you will have to think a little bit about what a good design would be.  Questions to ask yourself:</p>

<ul>
<li>How do I compute a point that is inset from the original geometry?</li>
<li>For faces, how do I shift the geometry in the normal direction? (You may wish to use the method <code>Face::normal()</code> here.)</li>
<li>What should I do as the offset geometry starts to look degenerate, 
e.g., shrinks to a point, or goes outside some reasonable bounds?</li>
<li>What should I do when the geometry is nonplanar?</li>
<li>Etc.</li>
</ul>

<p>The best way to get a feel for whether you have a good design is <em>to try it out!</em>
  Can you successfully and easily use this tool to edit your mesh?  Or 
is it a total pain, producing bizarre results?  You be the judge!</p>

<h4>Interface with global mesh operations</h4>

<p>To facilitate user interaction, as well as global mesh processing 
operations (described below), local mesh operations should return the 
following values when possible.  If the specified values are not 
available, you should think about a reasonable alternative value to 
return.  First and foremost, <em>the program should not crash!</em>  So 
for instance, you should not return a pointer to an element that was 
deleted.  Second, you should try as much as possible to return a value 
related to the argument.  For instance, if the user asks to flip an edge
 <code>e</code> that cannot be flipped (e.g., a boundary edge), the most natural solution would be to simply return <code>e</code>.  Likewise, if the user asks to erase an edge <code>e</code> that cannot be erased, a natural return value might be an adjacent (non-boundary) face.  Etc.</p>

<ul>
<li><code>HalfedgeMesh::flipEdge</code> - should return the edge that was flipped</li>
<li><code>HalfedgeMesh::splitEdge</code> - should return the inserted vertex</li>
<li><code>HalfedgeMesh::collapseEdge</code> - should return the new vertex, corresponding to the collapsed edge</li>
<li><code>HalfedgeMesh::collapseFace</code> - should return the new vertex, corresponding to the collapsed face</li>
<li><code>HalfedgeMesh::eraseVertex</code> - should return the new face, corresponding to the faces originally containing the vertex</li>
<li><code>HalfedgeMesh::eraseEdge</code> - should return the new face, corresponding to the faces originally containing the edge</li>
<li><code>HalfedgeMesh::bevelVertex</code> - should return the new face, corresponding to the beveled vertex</li>
<li><code>HalfedgeMesh::bevelEdge</code> - should return the new face, corresponding to the beveled edge</li>
<li><code>HalfedgeMesh::bevelFace</code> - should return the new, inset face</li>
</ul>

<hr>

<h2>Global Mesh Processing</h2>

<p>In addition to local operations on mesh connectivity, Scotty3D 
provides several global remeshing operations (as outlined in the User 
Guide).  Two different mechanisms are used to implement global 
operations:</p>

<ul>
<li><em>Repeated application of local operations.</em> Some mesh 
operations are most easily expressed by applying local operations (edge 
flips, etc.) to a sequence of mesh elements until the target output is 
achieved.  A good example is mesh simplification, which is a greedy 
algorithm that collapses one edge at a time (see further discussion 
below).</li>
<li><em>Global replacement of the mesh.</em> Other mesh operations are 
better expressed by temporarily storing new mesh elements in a simpler 
mesh data structure (e.g., an indexed list of faces) and completely 
re-building the halfedge data structure from this data.  A good example 
is Catmull-Clark subdivision, where every polygon must be simultaneously
 split into quadrilaterals (see further discussion below).</li>
</ul>

<p>Note that in general there are no inter-dependencies among global 
remeshing operations (except that some of them require a triangle mesh 
as input, which can be achieved via the method <code>HalfedgeMesh::triangulate</code>).</p>

<p>As a sanity check, each of your resampling algorithms should complete
 almost instantaneously (no more than a second or so) on meshes of a few
 hundred polygons. If performance is significantly worse than this, you 
may be repeatedly iterating over more elements than you really need to, 
or allocating/deallocating more memory than necessary.  A useful 
debugging technique is to print out (or otherwise keep track of, e.g., 
via an integer counter or a profiler) the number of times basic methods 
like <code>Halfedge::next()</code> or <code>HalfedgeMesh::newVertex()</code>
 are called during a single execution of one of your methods; for most 
methods this number should be some reasonably small constant (no more 
than, say, 1000!) times the number of elements in the mesh.</p>

<hr>

<h3>Triangulation</h3>

<p>A variety of geometry processing algorithms become easier to 
implement (or are only well defined) when the input consists purely of 
triangles.  The method <code>HalfedgeMesh::triangulate</code> converts 
any polygon mesh into a triangle mesh by splitting each polygon into 
triangles.  This transformation is performed in-place, i.e., the 
original mesh data is replaced with the new, triangulated data (rather 
than making a copy).  The <code>triangulate</code> method is basically just a wrapper around <code>HalfedgeMesh::splitPolygon</code>, which splits a single face <code>f</code>
 into triangles.  The implementation of this method will look much like 
the implementation of the local mesh operations (see the tutorial 
above).</p>

<p>There is more than one way to split a polygon into triangles.  Two 
common patterns are to connect every vertex to a single vertex, or to 
"zig-zag" the triangulation across the polygon:</p>

<p><img src="DeveloperManual_files/Scotty3DTriangulate.svg" alt="Scotty3DTriangulate"></p>

<p>The <code>splitPolygon</code> routine is not required to produce any particular triangulation so long as:</p>

<ul>
<li>all polygons in the output are triangles,</li>
<li>the vertex positions remain unchanged, and</li>
<li>the output is a valid, manifold halfedge mesh.</li>
</ul>

<p>Note that triangulation of nonconvex or nonplanar polygons may lead 
to geometry that is unattractive or difficult to interpret.  However, 
the purpose of this method is simply to produce triangular <em>connectivity</em>
 for a given polygon mesh, and correct halfedge connectivity is the only
 invariant that must be preserved by the implementation.  The <em>geometric</em>
 quality of the triangulation can later be improved by running other 
global algorithms (e.g., isotropic remeshing); ambitious developers may 
also wish to consult the following reference:</p>

<ul>
<li>Zou et al, <a href="http://www.cs.wustl.edu/%7Etaoju/research/triangulate_final.pdf">"An Algorithm for Triangulating Multiple 3D Polygons"</a></li>
</ul>

<hr>

<h3>Subdivision</h3>

<p>In image processing, we often have a low resolution image that we 
want to display at a higher resolution. Since we only have a few samples
 of the original signal, we need to somehow interpolate or <em>upsample</em>
 the image. One idea would be to simply cut each pixel into four, 
leaving the color values unchanged, but this leads to a blocky 
appearance. Instead we might try a more sophisticated scheme (like 
bilinear or trilinear interpolation) that yields a smoother appearance.</p>

<p>In geometry processing, one encounters the same situation: we may 
have a low-resolution polygon mesh that we wish to upsample for display,
 simulation, etc.  Simply splitting each polygon into smaller pieces 
doesn't help, because it does nothing to alleviate blocky silhouettes or
 chunky features. Instead, we need an upsampling scheme that nicely 
interpolates or approximates the original data. Polygon meshes are quite
 a bit trickier than images, however, since our sample points are 
generally at <em>irregular</em> locations, i.e., they are no longer found at regular intervals on a grid.</p>

<p>Three subdivision schemes are supported by Scotty3D: Linear, 
Catmull-Clark, and Loop.  The first two can be used on any polygon mesh,
 and should be implemented via the global replacement strategy described
 above.  Loop subdivision can be implemented using repeated application 
of local oeprations.  See further details below.</p>

<h4>Linear subdivision</h4>

<p>Although our ultimate goal is to produce a smooth approximation of 
the control cage, the first step is to simply update the connectivity 
(but not the vertex positions) so that the mesh has a larger number of 
elements.  This kind of basic splitting or "linear subdivision" is also 
useful for box modeling, when we simply want to increase the number of 
available control points.</p>

<p>Unlike most of the other global remeshing operations, linear (and 
Catmull-Clark) subdivision will proceed by completely replacing the 
original halfedge mesh with a new one.  The high-level procedure is:</p>

<ol>
<li>Generate a list of vertex positions for the new mesh.</li>
<li>Generate a list of polygons for the new mesh, as a list of indices into the new vertex list (a la "polygon soup").</li>
<li>Hand these two lists to the method <code>HalfedgeMesh::rebuild</code>, which rebuilds the halfedge connectivity from scratch.</li>
</ol>

<p>Given these lists, <code>rebuild</code> will take care of allocating halfedges, setting up <code>next</code> and <code>twin</code>
 pointers, etc., based on the list of polygons generated in step 
2---this routine is already implemented in the Scotty3D skeleton code.</p>

<p>Both linear and Catmull-Clark subdivision schemes will handle general
 $n$-gons (i.e., polygons with $n$ sides) rather than, say, quads only 
or triangles only.  Each $n$-gon (including but not limited to 
quadrilaterals) will be split into $n$ quadrailaterals according to the 
following template:</p>

<p><img src="DeveloperManual_files/Scotty3DQuadSubdivide.svg" alt="Scotty3DQuadSubdivide"></p>

<p>The high-level procedure is outlined in greater detail in <code>HalfedgeMesh::subdivideQuad</code>.</p>

<h5>Vertex positions</h5>

<p>For global linear or Catmull-Clark subdivision, the strategy for 
assigning new vertex positions may at first appear a bit strange: in 
addition to updating positions at vertices, we will also calculate 
vertex positions associated with the <em>edges</em> and <em>faces</em> 
of the original mesh.  Storing new vertex positions on edges and faces 
will make it extremely convenient to generate the polygons in our new 
mesh, since we can still use the halfedge data structure to decide which
 four positions get connected up to form a quadrilateral.  In 
particular, each quad in the new mesh will consist of:</p>

<ul>
<li>one new vertex associated with a face from the original mesh,</li>
<li>two new vertices associated with edges from the original mesh, and</li>
<li>one vertex from the original mesh.</li>
</ul>

<p>For linear subdivision, the rules for computing new vertex positions are very simple:</p>

<ul>
<li>New vertices at original faces are assigned the average coordinates of all corners of that face (i.e., the arithmetic mean).</li>
<li>New vertices at original edges are assigned the average coordinates of the two edge endpoints.</li>
<li>New vertices at original vertices are assigned the same coordinates as in the original mesh.</li>
</ul>

<p>These values should be assigned to the members <code>Face::newPosition</code>, <code>Edge::newPosition</code>, and <code>Vertex::newPosition</code>, respectively.  For instance, <code>f-&gt;newPosition = Vector3D( x, y, z );</code> will assign the coordinates (x,y,z) to the new vertex associated with face <code>f</code>.
  The general strategy for assigning these new positions is to iterate 
over all vertices, then all edges, then all faces, assigning appropriate
 values to <code>newPosition</code>.  <strong>Note:</strong> you <em>must</em> copy the original vertex position <code>Vertex::position</code> to the new vertex position <code>Vertex::newPosition</code>; these values will not be used automatically.</p>

<p>This step should be implemented in the method <code>HalfedgeMesh::computeLinearSubdivisionPositions</code> in <code>meshEdit.cpp</code>.</p>

<p>Once the new vertex positions have been assigned to elements of the 
halfedge mesh, they need to be accumulated into a single list of <em>all</em> vertex positions in the new mesh, which will be handed to <code>HalfedgeMesh::rebuild</code>.  It is important that <em>vertex coordinates in this list appear in the same order they were indexed!</em>
  For instance, if you index vertices, then edges, then faces, then the 
final vertex coordinate list should likewise contain coordinates from 
vertices, then coordinates from edges, then coordinates from faces.  
These vertex coordinates can be accumuluated using an object of type <code>vector&lt;Vector3D&gt;</code>,
 i.e., a dynamically-sized array of vertex positions.  The basic 
strategy is to loop over all vertices, then all edges, then all faces, 
calling <code>push_back</code> to append each new vertex coordinate to the list.  (See the next section for further discussion of the <code>vector</code> class.)  Further details are provided in the in-line comments.</p>

<p>This last step should be implemented in the method <code>HalfedgeMesh::buildSubdivisionVertexList</code> in <code>meshEdit.cpp</code>.</p>

<h5>Vertex indices</h5>

<p>In addition to new (x,y,z) coordinates, we also need to assign a unique <em>index</em>
 to each vertex in the new mesh---including those that are associated 
with edges and faces.  In other words, every vertex, edge, and face in 
the mesh will be assigned an integer between 0 and $N-1$, where $N$ is 
the total number of vertices <em>plus</em> edges <em>plus</em> faces in the original mesh.  A simple strategy for assigning these indices is:</p>

<ol>
<li>Initialize a counter to zero.</li>
<li>Iterate over vertices, assigning the index of the current vertex to the counter value, and incrementing the counter.</li>
<li>Iterate over edges, assigning the index of the current edge to the counter value, and incrementing the counter.</li>
<li>Iterate over faces, assigning the index of the current face to the counter value, and incrementing the counter.</li>
</ol>

<p>Note that the particular choice of indices does not matter---the only
 things you must guarantee are that (i) every mesh element is assigned a
 valid index, and (ii) no two mesh elements share the same index.</p>

<h5>Polygons</h5>

<p>Unlike the local operations described above, which are applied one 
element after another, in linear and Catmull-Clark subdivision <em>all polygons are subdivided simultaneously</em>.  In other words, if we focus on the whole mesh (rather than a single polygon), then we are</p>

<ul>
<li>creating one new vertex for each edge,</li>
<li>creating one new vertex for each face, and</li>
<li>keeping all the vertices of the original mesh.</li>
</ul>

<p>These vertices are then connected up to form quadrilaterals ($n$ 
quadrilaterals for each $n$-gon).  Rather than directly modifying the 
halfedge connectivity, new quads will be collected in a much simpler 
mesh data structure: a list of polygons.  Note that with this 
subdivision scheme, <em>every</em> polygon in the output mesh will be a quadrilateral, even if the input contains triangles, pentagons, etc.</p>

<p>In Scotty3D, a list of polygons can be declared as</p>

<pre class="prettyprint"><code><span class="pln">vector</span><span class="pun">&lt;</span><span class="pln"> vector</span><span class="pun">&lt;</span><span class="typ">Index</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> quads</span><span class="pun">;</span></code></pre>

<p>where <code>vector</code> is a <a href="http://en.cppreference.com/w/cpp/container/vector">class from the C++ standard template library</a>, representing a dynamically-sized array.  An <code>Index</code> is just another name for a <code>size_t</code>,
 which is the standard C++ type for integers that specify an element of 
an array.  Polygons can be created by allocating a list of appropriate 
size, then specifying the indices of each vertex in the polygon.  For 
example:</p>

<pre class="prettyprint"><code><span class="pln">vector</span><span class="pun">&lt;</span><span class="typ">Index</span><span class="pun">&gt;</span><span class="pln"> quad</span><span class="pun">(</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="pun">);</span><span class="pln"> </span><span class="com">// allocate an array with four elements</span><span class="pln">
</span><span class="com">// Build a quad with vertices specified by integers (a,b,c,d), starting at zero.</span><span class="pln">
</span><span class="com">// These indices should correspond to the indices computing when assigning vertex</span><span class="pln">
</span><span class="com">// positions, as described above.</span><span class="pln">
quad</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">;</span><span class="pln">
quad</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> b</span><span class="pun">;</span><span class="pln">
quad</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> c</span><span class="pun">;</span><span class="pln">
quad</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> d</span><span class="pun">;</span></code></pre>

<p>Once a quad has been created, it can be added to the list of quads by using the method <code>vector::push_back</code>, which appends an item to a vector:</p>

<pre class="prettyprint"><code><span class="pln">vector</span><span class="pun">&lt;</span><span class="pln"> vector</span><span class="pun">&lt;</span><span class="typ">Index</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> newPolygons</span><span class="pun">;</span><span class="pln">
newPolygons</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln"> quad </span><span class="pun">);</span></code></pre>

<p>The full array of new polygons will then be passed to the method <code>HalfedgeMesh::rebuild</code>, together with the new vertex positions.</p>

<p>This step should be implemented in the method <code>HalfedgeMesh::buildSubdivisionFaceList</code> in <code>meshEdit.cpp</code>.</p>

<h4>Catmull-Clark subdivision</h4>

<p>The only difference between Catmull-Clark and linear subdivision is 
the choice of positions for new vertices.  Whereas linear subdivision 
simply takes a uniform average of the old vertex positions, 
Catmull-Clark uses a very carefully-designed <em>weighted</em> average 
to ensure that the surface converges to a nice, round surface as the 
number of subdivision steps increases.  The original scheme is described
 in the paper <em>``Recursively generated B-spline surfaces on arbitrary topological meshes''</em>
 by (Pixar co-founder) Ed Catmull and James Clark.  Since then, the 
scheme has been thoroughly discussed, extended, and analyzed; more 
modern descriptions of the algorithm may be easier to read, including 
those from the <a href="https://en.wikipedia.org/wiki/Catmull_Clark_subdivision_surface">Wikipedia</a> and <a href="http://www.rorydriscoll.com/2008/08/01/catmull-clark-subdivision-the-basics/">this webpage</a>.  In short, the new vertex positions can be calculated by:</p>

<ol>
<li>setting the new vertex position at each face f to the average of all its original vertices (exactly as in linear subdivision),</li>
<li>setting the new vertex position at each edge e to the average of the
 new face positions (from step 1) and the original endpoint positions, 
and</li>
<li>setting the new vertex position at each vertex v to the weighted sum</li>
</ol>

<p>$$ \frac{Q + 2R + (n-3)S}{n}, $$</p>

<p>where $n$ is the degree of vertex $v$ (i.e., the number of faces containing $v$), and</p>

<ul>
<li>$Q$ is the average of all new face position for faces containing $v$,</li>
<li>$R$ is the average of all new edge positions for edges containing $v$, and</li>
<li>$S$ is the original vertex position for vertex $v$.</li>
</ul>

<p>In other words, the new vertex positions are an "average of averages."  (Note that you <em>will</em> need to divide by $n$ <em>both</em> when computing $Q$ and $R$, <em>and</em> when computing the final, weighted value---this is not a typo!)</p>

<p>Apart from changing the way vertex positions are computed, there 
should be no difference in your implementation of linear and 
Catmull-Clark subdivision.</p>

<p>This step should be implemented in the method <code>HalfedgeMesh::computeCatmullClarkPositions</code> in <code>meshEdit.cpp</code>.</p>

<h4>Loop subdivision</h4>

<p>Loop subdivision (named after <a href="http://research.microsoft.com/en-us/um/people/cloop/">Charles Loop</a>) is a standard approximating subdivision scheme for triangle meshes. At a high level, it consists of two basic steps:</p>

<ol>
<li>Split each triangle into four by connecting edge midpoints (sometimes called "4-1 subdivision").</li>
<li>Update vertex positions as a particular weighted average of neighboring positions.</li>
</ol>

<p>The 4-1 subdivision looks like this:</p>

<p></p><center>
<img src="DeveloperManual_files/41Subdivision.png" alt="4-1 Subdivision" height="157" width="500">
</center><p></p>

<p>And the following picture illustrates the weighted average:</p>

<p></p><center>
<img src="DeveloperManual_files/LoopWeights.png" alt="Loop subdivision weights" height="157" width="500">
</center><p></p>

<p>In words, the new position of an old vertice is (1 - nu) times the 
old position + u times the sum of the positions of all of its neighbors.
 The new position for a newly created vertex v that splits Edge AB and 
is flanked by opposite vertices C and D across the two faces connected 
to AB in the original mesh will be 3/8 * (A + B) + 1/8 * (C + D).  If we
 repeatedly apply these two steps, we will converge to a fairly smooth 
approximation of our original mesh.</p>

<p>In contrast to linear and Catmull-Clark subdivision, Loop subdivision
 should be implemented using the local mesh operations described above 
(simply because it provides an alternative perspective on subdivision 
implementation, which can be useful in different scenarios).  In 
particular, 4-1 subdivision can be achieved by applying the following 
strategy:</p>

<ol>
<li>Split every edge of the mesh <em>in any order whatsoever</em>.</li>
<li>Flip any new edge that touches a new vertex and an old vertex.</li>
</ol>

<p>The following pictures (courtesy Denis Zorin) illustrate this idea:</p>

<p></p><center>
<img src="DeveloperManual_files/FlippingSubdivision.png" alt="Subdivision via flipping" height="225" width="500">
</center><p></p>

<p>Notice that only blue (and not black) edges are flipped in this 
procedure; as described above, edges in the split mesh should be flipped
 if and only if they touch both an original vertex <em>and</em> a new vertex (i.e., a midpoint of an original edge).</p>

<p>When working with dynamic mesh data structures (like a halfedge mesh), one must think <strong>very carefully</strong>
 about the order in which mesh elements are processed---it is quite easy
 to delete an element at one point in the code, then try to access it 
later (typically resulting in a crash!). For instance, suppose we write a
 loop like this:</p>

<pre class="prettyprint"><code><span class="com">// iterate over all edges in the mesh</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="typ">EdgeIter</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">edgesBegin</span><span class="pun">();</span><span class="pln"> e </span><span class="pun">!=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">edgesEnd</span><span class="pun">();</span><span class="pln"> e</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">some condition </span><span class="kwd">is</span><span class="pln"> met</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    mesh</span><span class="pun">.</span><span class="pln">splitEdge</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Although this routine looks straightforward, it can very easily 
crash!  The reason is fairly subtle: we are iterating over edges in the 
mesh by incrementing the iterator <code>e</code> (via the expression <code>e++</code>). But since <code>splitEdge()</code> is allowed to create and delete mesh elements, it might deallocate the edge pointed to by <code>e</code> before we increment it!  To be safe, one should instead write a loop like this:</p>

<pre class="prettyprint"><code><span class="com">// iterate over all edges in the mesh</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">nEdges</span><span class="pun">();</span><span class="pln">
</span><span class="typ">EdgeIter</span><span class="pln"> e </span><span class="pun">=</span><span class="pln"> mesh</span><span class="pun">.</span><span class="pln">edgesBegin</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

  </span><span class="com">// get the next edge NOW!</span><span class="pln">
  </span><span class="typ">EdgeIter</span><span class="pln"> nextEdge </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">;</span><span class="pln">
  nextEdge</span><span class="pun">++;</span><span class="pln">

  </span><span class="com">// now, even if splitting the edge deletes it...</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">some condition </span><span class="kwd">is</span><span class="pln"> met</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    mesh</span><span class="pun">.</span><span class="pln">splitEdge</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// ...we still have a valid reference to the next edge.</span><span class="pln">
  e </span><span class="pun">=</span><span class="pln"> nextEdge</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Note that this loop is just <em>one example</em> -- in general, you 
should think about which elements might be affected by a local mesh 
operation when writing your loops. Likewise, you can make life easier on
 yourself by making sure that your atomic edge operations provide 
certain guarantees. For instance, if your implementation of <code>HalfedgeMesh::flipEdge()</code>
 guarantees that no edges will be created or destroyed (as it should), 
then you can safely do edge flips inside a loop without worrying about 
these kinds of side effects.</p>

<p>For Loop subdivision, there are some additional data members that 
will make it easy to keep track of the data needed to update the 
connectivity and vertex positions. In particular:</p>

<ul>
<li><code>Vertex::newPosition</code> can be used as temporary storage for the new position (computed via the weighted average above).  Note that you should <em>not</em> change the value of <code>Vertex::position</code> until <em>all</em> the new vertex positions have been computed -- otherwise, you are taking averages of values that have already been averaged!</li>
<li>Likewise, <code>Edge::newPosition</code> can be used to store the 
position of the vertices that will ultimately be inserted at edge 
midpoints.  Again, these values should be computed from the original 
values (before subdivision), and applied to the new vertices only at the
 very end. The <code>Edge::newPosition</code>value will be used for the 
position of the vertex that will appear along the old edge after the 
edge is split. We precompute the position of the new vertex before 
splitting the edges and allocating the new vertices because it is easier
 to tansverse the simpler original mesh to find the positions for the 
weighted average that determines the positions of the new vertices.</li>
<li><code>Vertex::isNew</code> can be used to flag whether a vertex was 
part of the original mesh, or is a vertex newly inserted by subdivision 
(at an edge midpoint).</li>
<li><code>Edge::isNew</code> likewise flags whether an edge is a piece 
of an edge in the original mesh, or is an entirely new edge created 
during the subdivision step.</li>
</ul>

<p>Given this setup, we strongly suggest that it will be easiest to 
implement subdivision according to the following "recipe" (though you 
are of course welcome to try doing things a different way!). The basic 
strategy is to <em>first</em> compute the new vertex positions (storing the results in the <code>newPosition</code> members of both vertices and edges), and only <em>then</em>
 update the connectivity. Doing it this way will be much easier, since 
traversal of the original (coarse) connectivity is much simpler than 
traversing the new (fine) connectivity. In more detail:</p>

<ol>
<li>Mark all vertices as belonging to the original mesh by setting <code>Vertex::isNew</code> to <code>false</code> for all vertices in the mesh.</li>
<li>Compute updated positions for all vertices in the original mesh using the vertex subdivision rule, and store them in <code>Vertex::newPosition</code>.</li>
<li>Compute new positions associated with the vertices that will be inserted at edge midpoints, and store them in <code>Edge::newPosition</code>.</li>
<li>Split every edge in the mesh, being careful about how the loop is 
written.  In particular, you should make sure to iterate only over edges
 of the original mesh.  Otherwise, you will keep splitting edges that 
you just created!</li>
<li>Flip any new edge that connects an old and new vertex.</li>
<li>Finally, copy the new vertex positions (<code>Vertex::newPosition</code>) into the usual vertex positions (<code>Vertex::position</code>).</li>
</ol>

<p>If you made the requested modification to the return value of <code>HalfedgeMesh::splitEdge()</code>
 (see above), then an edge split will now return an iterator to the 
newly inserted vertex, and the halfedge of this vertex will point along 
the edge of the original mesh. This iterator is useful because it can be
 used to (i) flag the vertex returned by the split operation as a new 
vertex, and (ii) flag each outgoing edge as either being new or part of 
the original mesh.  (In other words, Step 3 is a great time to set the 
members <code>isNew</code> for vertices and edges created by the split. It is also a good time to copy the <code>newPosition</code> field from the edge being split into the <code>newPosition</code> field of the newly inserted vertex.)</p>

<p>You might try implementing this algorithm in stages, e.g., <em>first</em> see if you can correctly update the connectivity, <em>then</em> worry about getting the vertex positions right. Some examples below illustrate the correct behavior of the algorithm.</p>

<p></p><center>
<img src="DeveloperManual_files/SubdivisionExamples.png" alt="Loop subdivision examples" height="435" width="700">
</center><p></p>

<hr>

<h3>Simplification</h3>

<p></p><center>
<img src="DeveloperManual_files/QEMSimplification.png" alt="Surface simplification via quadric error metric" height="222" width="754">
</center><p></p>

<p>Just as with images, meshes often have far more samples than we 
really need.  The simplification method in Scotty3D simplifies a given 
triangle mesh by applying <em>quadric error simplification</em> (note that this method is for <strong>triangle meshes only</strong>!). This method was originally developed at CMU by Michael Garland and Paul Heckbert, in their paper <a href="http://www.cs.cmu.edu/%7E./garland/quadrics/quadrics.html">Surface Simplification Using Quadric Error Metrics</a>.
 (Looking at this paper -- or the many slides and presentations online 
that reference it -- may be very helpful in understanding and 
implementing this part of the assignment!)</p>

<p>The basic idea is to iteratively collapse edges until we reach the 
desired number of triangles.  The more edges we collapse, the simpler 
the mesh becomes.  The only question is: which edges should we collapse?
 And where should we put the new vertex when we collapse an edge? 
Finding the sequence of edge collapses (and vertex positions) that give 
an <em>optimal</em> approximation of the surface would be very difficult
 -- likely impossible! Garland and Heckbert instead proposed a simple, 
greedy scheme that works quite well in practice, and is the basis of 
many mesh simplification tools today. Roughly speaking, we're going to 
write down a function that measures the distance to a given triangle, 
and then "accumulate" this function as many triangles get merged 
together.</p>

<p>More precisely, we can write the distance d of a point $x$ to a plane with normal $N$ passing through a point $p$ as</p>

<p>$$d(x) = N \cdot (x - p)$$</p>

<p></p><center>
<img src="DeveloperManual_files/PlaneNormalEquation.png" alt="Plane normal equation" height="298" width="400">
</center><p></p>

<p>In other words, we measure the extent of the vector from $p$ to $x$ 
along the normal direction. This quantity gives us a value that is 
either <em>positive</em> (above the plane), or <em>negative</em> (below 
the plane).  Suppose that $x$ has coordinates $(x,y,z)$, $N$ has 
coordinates $(a,b,c)$, and let $d = N \cdot p$, then in <em>homogeneous</em> coordinates, the distance to the plane is just</p>

<p>$$u \cdot v$$</p>

<p>where $u = (x,y,z,1)$ and $v = (a,b,c,d)$. When we're measuring the 
quality of an approximation, we don't care whether we're above or below 
the surface; just how <em>far away</em> we are from the original surface. Therefore, we're going to consider the <em>square</em> of the distance, which we can write in homogeneous coordinates as</p>

<p>$$(u \cdot v)^2 = u^T v v^T u$$</p>

<p>where $^T$ denotes the transpose of a vector. The term $vv^T$ is an <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a> of the vector $v$ with itself, which gives us a symmetric matrix $K = vv^T$. In components, this matrix would look like</p>

<pre class="prettyprint"><code><span class="pln">a</span><span class="pun">^</span><span class="lit">2</span><span class="pln">   ab    ac   ad
ab    b</span><span class="pun">^</span><span class="lit">2</span><span class="pln">   bc   bd
ac    bc    c</span><span class="pun">^</span><span class="lit">2</span><span class="pln">  cd
ad    bd    cd   d</span><span class="pun">^</span><span class="lit">2</span></code></pre>

<p>but in Scotty3D it can be constructed by simply calling the method <code>outer( Vector4D, Vector4D )</code> in <code>matrix4x4.h</code>
 that takes a pair of vectors in homogeneous coordinates and returns the
 outer product as a 4x4 matrix. We will refer to this matrix as a 
"quadric," because it also describes a <a href="https://en.wikipedia.org/wiki/Quadric">quadric surface</a>.</p>

<p>The matrix $K$ tells us something about the distance to a plane. We can also get some idea of how far we are from a <em>vertex</em>
 by considering the sum of the squared distances to the planes passing 
through all triangles that touch that vertex.  In other words, we will 
say that the distance to a small neighborhood around the vertex i can be
 approximated by the sum of the quadrics on the incident faces ijk:</p>

<p>$$K_i = \sum_{\text{all faces ijk touching vertex i}} K_{ijk}$$</p>

<p></p><center>
<img src="DeveloperManual_files/VertexNormals.png" alt="Vertex normals" height="318" width="325">
</center><p></p>

<p>Likewise, the distance to an <em>edge</em> ij will be approximated by the sum of the quadrics at its two endpoints:</p>

<p>$$K_{ij} = K_i + K_j$$</p>

<p>In your code, we have added a member <code>Matrix4x4 Face::quadric</code> and <code>Matrix4x4 Vertex::quadric</code>
 to the faces and vertices of the halfedge mesh.  The sums above should 
then be easy to compute -- you can just add up the Matrix4x4 objects 
around a vertex or along an edge using the usual "+" operator.  You do 
not need to write an explicit loop over the 16 entries of the matrix.</p>

<p>Once you have a quadric $K$ associated with an edge $ij$, you can ask
 the following question: if we collapse the edge to a point $x$, where 
should we put the new point so that it minimizes the (approximate) 
distance to the original surface?  In other words, where should it go so
 that it minimizes the quantity $x^T K x$?</p>

<p>Just like any other function, we can look for the minimum by taking 
the derivative with respect to $x$ and setting it equal to zero. (By the
 way, in this case we're always going to get a <em>minimum</em> and not a <em>maximum</em> because the matrices K are all <a href="https://en.wikipedia.org/wiki/Positive-definite_matrix">positive-definite</a>.)  In other words, we want to solve the small (4x4) linear system</p>

<p>$$K u = 0$$</p>

<p>for the optimal position $u$, expressed in homogeneous coordinates. 
We can simplify this situation a bit by remembering that the homogeneous
 coordinate for a point in 3-space is just 1.  After a few simple 
manipulations, then, we can rewrite this same system as an even smaller 
3x3 linear system</p>

<p>$$Ax = b$$</p>

<p>where A is the upper-left 3x3 block of K, and b is <em>minus</em> the upper-right 3x1 column.  In other words, the entries of A are just</p>

<p>$$
\left[
\begin{matrix}
a^2 &amp;  ab  &amp;  ac  \
ab  &amp;  b^2 &amp;  bc  \
ac  &amp;  bc  &amp;  c^2 \
\end{matrix}
\right]
$$</p>

<p>and the entries of b are</p>

<p>$$
\left[
\begin{matrix}
-ad \
-bd \
-cd \
\end{matrix}
\right]
$$</p>

<p>The cost associated with this solution can be found by plugging $x$ back into our original expression, i.e., the cost is just</p>

<p>$$x^T K x$$</p>

<p>where $K$ is the quadric associated with the edge. Fortunately, <em>you do not need to write any code to solve this linear system</em>. It can be solved using the method <code>Matrix3x3::inv()</code> which computes the inverse of a 3x3 matrix. In particular, you can write something like this:</p>

<pre class="prettyprint"><code><span class="typ">Matrix3x3</span><span class="pln"> A</span><span class="pun">;</span><span class="pln"> </span><span class="com">// computed by accumulating quadrics and then extacting the upper-left 3x3 block</span><span class="pln">
</span><span class="typ">Vector3D</span><span class="pln"> b</span><span class="pun">;</span><span class="pln">  </span><span class="com">// computed by extracting minus the upper-right 3x1 column from the same matrix</span><span class="pln">
</span><span class="typ">Vector3D</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> A</span><span class="pun">.</span><span class="pln">inv</span><span class="pun">()</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> b</span><span class="pun">;</span><span class="pln"> </span><span class="com">// solve Ax = b for x, by hitting both sides with the inverse of A</span></code></pre>

<p>If you're a bit lost at this point, don't worry! There are a lot of 
details to go through, and we'll summarize everything again in the 
implementation section.  The main idea to keep in mind right now is:</p>

<ul>
<li>we're storing a matrix at every vertex that encodes (roughly) the distance to the surface, and</li>
<li>for each edge, we want to find the point that is (roughly) as close 
as possible to the surface, according to the matrices at its endpoints.</li>
</ul>

<p>As we collapse edges, the matrices at endpoints will be combined by 
just adding them together. So, as we perform more and more edge 
collapses, these matrices will try to capture the distance to a larger 
and larger region of the original surface.</p>

<p>The one final thing we want to think about is performance. At each iteration, we want to collapse the edge that results in the <em>least</em>
 deviation from our original surface. But testing every edge, every 
single iteration sounds pretty expensive! (Something like O(n^2).) 
Instead, we're going to put all our edges into a <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a>
 that efficiently keeps track of the "best" edge for us, even as we add 
and remove edges from our mesh. In the code framework, we actually 
introduce a new class called an <code>EdgeRecord</code> that encodes all the essential information about our edge:</p>

<pre class="prettyprint"><code><span class="com">// An edge record keeps track of all the information about edges</span><span class="pln">
</span><span class="com">// that we need while applying our mesh simplification algorithm.</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EdgeRecord</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">public</span><span class="pun">:</span><span class="pln">
    </span><span class="typ">EdgeRecord</span><span class="pun">(</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">)</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
    </span><span class="typ">EdgeRecord</span><span class="pun">(</span><span class="pln"> </span><span class="typ">EdgeIter</span><span class="pun">&amp;</span><span class="pln"> _edge </span><span class="pun">);</span><span class="pln">
    </span><span class="com">// The second constructor takes an edge, and computes all</span><span class="pln">
    </span><span class="com">// the essential data.  In particular, it computes the sum</span><span class="pln">
    </span><span class="com">// of the quadrics at the two endpoints, and solves for the</span><span class="pln">
    </span><span class="com">// optimal midpoint position as measured by this quadric.</span><span class="pln">
    </span><span class="com">// It also stores the value of this quadric as the "score"</span><span class="pln">
    </span><span class="com">// used by the priority queue.</span><span class="pln">

    </span><span class="typ">EdgeIter</span><span class="pln"> edge</span><span class="pun">;</span><span class="pln"> </span><span class="com">// the edge referred to by this record</span><span class="pln">

    </span><span class="typ">Vector3D</span><span class="pln"> optimalPoint</span><span class="pun">;</span><span class="pln"> </span><span class="com">// the optimal point, if we were</span><span class="pln">
                           </span><span class="com">// to collapse this edge next</span><span class="pln">

    </span><span class="kwd">double</span><span class="pln"> cost</span><span class="pun">;</span><span class="pln"> </span><span class="com">// the cost associated with collapsing this edge,</span><span class="pln">
                 </span><span class="com">// which is very (very!) roughly something like</span><span class="pln">
                 </span><span class="com">// the distance we'll deviate from the original</span><span class="pln">
                 </span><span class="com">// surface if this edge is collapsed</span><span class="pln">
</span><span class="pun">};</span></code></pre>

<p>To initialize an edge record for a given edge, you just have to write</p>

<pre class="prettyprint"><code><span class="typ">EdgeRecord</span><span class="pln"> myRecord</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span></code></pre>

<p>In other words, you hand it the edge to be initialized. This record 
in turn gets added to a priority queue, which stores all the halfedges, 
sorted according to the cost of collapsing them:</p>

<pre class="prettyprint"><code><span class="typ">MutablePriorityQueue</span><span class="pln"> queue</span><span class="pun">;</span><span class="pln">
queue</span><span class="pun">.</span><span class="pln">insert</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span></code></pre>

<p>If we ever want to know what the best edge is to collapse, we can just look at the top of the priority queue:</p>

<pre class="prettyprint"><code><span class="typ">EdgeRecord</span><span class="pln"> bestEdge </span><span class="pun">=</span><span class="pln"> queue</span><span class="pun">.</span><span class="pln">top</span><span class="pun">();</span></code></pre>

<p>More documentation is provided in the header file <code>MutablePriorityQueue.h</code>.</p>

<p>Though conceptually sophisticated, quadric error simplification is 
actually not too hard to implement.  It basically boils down to two 
methods:</p>

<pre class="prettyprint"><code><span class="typ">EdgeRecord</span><span class="pun">::</span><span class="typ">EdgeRecord</span><span class="pun">(</span><span class="pln"> </span><span class="typ">EdgeIter</span><span class="pln"> e </span><span class="pun">);</span><span class="pln">            </span><span class="com">// initializer for an edge record</span><span class="pln">
</span><span class="typ">MeshResampler</span><span class="pun">::</span><span class="pln">downsample</span><span class="pun">(</span><span class="pln"> </span><span class="typ">HalfedgeMesh</span><span class="pun">&amp;</span><span class="pln"> mesh </span><span class="pun">);</span><span class="pln"> </span><span class="com">// downsampling via quadric error simplification</span></code></pre>

<p>As discussed above, the edge record initializer should:</p>

<ol>
<li>Compute a quadric for the edge as the sum of the quadrics at endpoints.</li>
<li>Build a 3x3 linear system for the optimal collapsed point, as described above.</li>
<li>Solve this system and store the optimal point in <code>EdgeRecord::optimalPoint</code>.</li>
<li>Compute the corresponding error value and store it in <code>EdgeRecord::cost</code>.</li>
<li>Store the edge in <code>EdgeRecord::edge</code>.</li>
</ol>

<p>The downsampling routine can then be implemented by following this basic recipe:</p>

<ol>
<li>Compute quadrics for each face by simply writing the plane equation 
for that face in homogeneous coordinates, and building the corresponding
 quadric matrix using <code>Matrix4x4::outer()</code>.  This matrix should be stored in <code>Face::quadric</code>.</li>
<li>Compute an initial quadric for each vertex by adding up the quadrics
 at all the faces touching that vertex. This matrix should be stored in <code>Vertex::quadric</code>.  (Note that these quadrics will get updated as edges are collapsed.)</li>
<li>For each edge, create an <code>EdgeRecord</code> and insert it into one global <code>MutablePriorityQueue</code>.</li>
<li>Until a target number of triangles is reached, collapse the 
best/cheapest edge (as determined by the priority queue), and set the 
quadric at the new vertex to the sum of the quadrics at the endpoints of
 the original edge.  You will also have to update the cost of any edge 
connected to this vertex.</li>
</ol>

<p>The algorithm should terminate when a target number of triangles is 
reached -- for the purpose of this assignment, you should set this 
number to 1/4th the number of triangles in the input (since subdivision 
will give you a factor of 4 in the opposite direction). Note that to <em>get</em> the best element from the queue you call <code>MutablePriorityQueue::top()</code>, whereas to <em>remove</em> the best element from the top you must call <code>MutablePriorityQueue::pop()</code> (the separation of these two tasks is fairly standard in STL-like data structures).</p>

<p>As with subdivision, it is critical that you carefully reason about 
which mesh elements get added/deleted in what order -- particularly in 
Step 4. A good way to implement Step 4 would be:</p>

<ol>
<li>Get the cheapest edge from the queue.</li>
<li><strong>Remove the cheapest edge from the queue by calling <code>pop()</code>.</strong></li>
<li>Compute the new quadric by summing the quadrics at its two endpoints.</li>
<li><strong>Remove any edge touching either of its endpoints from the queue.</strong></li>
<li>Collapse the edge.</li>
<li>Set the quadric of the new vertex to the quadric computed in Step 2.</li>
<li><strong>Insert any edge touching the new vertex into the queue, creating new edge records for each of them.</strong></li>
</ol>

<p><em>Note:</em> Step 2 is highlighted, because these instruction used 
to erroneously recommend that the pop be done at the end. The pop of the
 cheapest edge needs to occur before any modifications are made to the 
queue, because otherwise the edge you are processing might not be the 
cheapest edge at the end of the 7 step process.</p>

<p>Steps 4 and 7 are highlighted because it is easy to get these steps 
wrong. For instance, if you collapse the edge first, you may no longer 
be able to access the edges that need to be removed from the queue.</p>

<p>A working implementation should look something like the examples 
below. You may find it easiest to implement this algorithm in stages.  
For instance, <em>first</em> get the edge collapses working, using just the edge midpoint rather than the optimal point, <em>then</em> worry about solving for the point that minimizes quadric error.</p>

<p></p><center>
<img src="DeveloperManual_files/QEMExamples.png" alt="Quadric error simplification examples" height="700" width="600">
</center><p></p>

<h3>Isotropic Remeshing</h3>

<p>Another thing we might want to do with a mesh is keep the number of 
samples roughly the same, while improving the shape of individual 
triangles. The isotropic remeshing algorithm tries to make the mesh as 
"uniform" as possible, i.e., triangles as close as possible to 
equilaterial triangles of equal size, and vertex degrees as close as 
possible to 6 (note: this algorithm is for <strong>triangle meshes only</strong>).  The algorithm you will implement is based on the paper <a href="http://graphics.uni-bielefeld.de/publications/disclaimer.php?dlurl=sgp04.pdf">Botsch and Kobbelt, "A Remeshing Approach to Multiresolution Modeling"</a> (Section 4), and can be summarized in just a few simple steps:</p>

<ol>
<li>If an edge is too long, split it.</li>
<li>If an edge is too short, collapse it.</li>
<li>If flipping an edge improves the degree of neighboring vertices, flip it.</li>
<li>Move vertices toward the average of their neighbors.</li>
</ol>

<p>Repeating this simple process several times typically produces a mesh
 with fairly uniform triangle areas, angles, and vertex degrees. 
However, each of the steps deserves slightly more explanation.</p>

<h4>Edge Splitting / Collapsing</h4>

<p>Ultimately we want all of our triangles to be about the same size, 
which means we want edges to all have roughly the same length. As 
suggested in the paper by Botsch and Kobbelt, we will aim to keep our 
edges no longer than 4/3rds of the <strong>mean</strong> edge length $L$
 in the input mesh, and no shorter than 4/5ths of $L$. In other words, 
if an edge is longer than 4$L$/3, split it; if it is shorter than 
4$L$/5, collapse it. We recommend performing all of the splits first, 
then doing all of the collapses (though as usual, you should be careful 
to think about when and how mesh elements are being 
allocated/deallocated).</p>

<h4>Edge Flipping</h4>

<p>We want to flip an edge any time it reduces the total deviation from 
regular degree (degree 6). In particular, let $a_1$, $a_2$ be the 
degrees of an edge that we're thinking about flipping, and let $b_1$, 
$b_2$ be the degrees of the two vertices across from this edge. The 
total deviation in the initial configuration is $|a_1-6| + |a_2-6| + 
|b_1-6| + |b_2-6|$. You should be able to <em>easily</em> compute the deviation after the edge flip <strong>without actually performing the edge flip</strong>;
 if this number decreases, then the edge flip should be performed. We 
recommend flipping all edges in a single pass, after the edge collapse 
step.</p>

<h4>Vertex Averaging</h4>

<p>Finally, we also want to optimize the geometry of the vertices. A 
very simple heuristic is that a mesh will have reasonably well-shaped 
elements if each vertex is located at the center of its neighbors. To 
keep your code clean and simple, we ask that you implement the method <code>Vertex::computeCentroid()</code> which should compute the average position of the neighbors and store it in the member <code>Vertex::centroid</code>. The reason this value must be stored in a temporary variable and not <em>immediately</em>
 used to replace the current position is similar to the reason we stored
 temporary vertex positions in our subdivision scheme: we don't want to 
be taking averages of vertices that have already been averaged. Doing so
 can yield some bizarre behavior that depends on the order in which 
vertices are traversed (if you're interested in learning more about this
 issue, Google around for the terms "Jacobi iterations" and 
"Gauss-Seidel). So, your code should (i) first compute the centroid for 
all vertices, and (ii) then update the vertices with new positions.</p>

<p></p><center>
<img src="DeveloperManual_files/LaplacianSmoothing.png" alt="Laplacian smoothing" height="183" width="500">
</center><p></p>

<p>How exactly should the positions be updated?  One idea is to simply 
replace each vertex position with its centroid.  We can make the 
algorithm slightly more stable by moving <em>gently</em> toward the centroid, rather than immediately snapping the vertex to the center. For instance, if <strong>p</strong> is the original vertex position and <strong>c</strong>
 is the centroid, we might compute the new vertex position as $q = p + 
w(c - p)$ where w is some weighting factor between 0 and 1 (we use 1/5 
in the examples below). In other words, we start out at <strong>p</strong> and move a little bit in the update direction $v = c - p$.</p>

<p>Another important issue here is that if our update direction $v$ has a large <em>normal</em>
 component, then we'll end up pushing the surface in or out, rather than
 just sliding our sample points around on the surface.  As a result, the
 shape of the surface will change much more than we'd like (try it!).  
To ameliorate this issue, we will move the vertex only in the <em>tangent</em>
 direction, which we can do by projecting out the normal component, 
i.e., by replacing $v$ with $v - (N \cdot v)N$, where $N$ is the unit 
normal at the vertex.  To get this normal, you will implement the method
 <code>Vertex::normal()</code>, which computes the vertex normal as the 
area-weighted average of the incident triangle normals.  In other words,
 at a vertex i the normal points in the direction</p>

<p>$$\sum_{\text{triangles ijk touching vertex i}} A_{ijk} N_{ijk}$$</p>

<p>where $A_{ijk}$ is the area of triangle ijk, and $N_{ijk}$ is its 
unit normal; this quantity can be computed directly by just taking the 
cross product of two of the triangle's edge vectors (properly oriented).</p>

<h4>Implementation</h4>

<p>The final implementation requires very little information beyond the description above; the basic recipe is:</p>

<ol>
<li>Compute the mean edge length $L$ of the input.</li>
<li>Split all edges that are longer than 4$L$/3.</li>
<li>Collapse all edges that are shorter than 4$L$/5.</li>
<li>Flip all edges that decrease the total deviation from degree 6.</li>
<li>Compute the centroids for all the vertices.</li>
<li>Move each vertex in the tangent direction toward its centroid.</li>
</ol>

<p>Repeating this procedure about 5 or 6 times should yield results like
 the ones seen below; you may want to repeat the smoothing step 10-20 
times for each "outer" iteration.</p>

<p></p><center>
<img src="DeveloperManual_files/IsotropicExamples.png" alt="Isotropic remeshing examples" height="637" width="700">
</center><p></p>

<h2>Path Tracing</h2>

<p>Following the design of modern ray tracing systems, we have chosen to
 implement the ray tracing components of the Assignment 3 starter code 
in a very modular fashion.  Therefore, unlike previous assignments, your
 implementation will touch a number of files in the starter code.  The 
main structure of the code base is:</p>

<ul>
<li>The main workhorse class is <code>Pathtracer</code> defined in <i class="icon-file"> </i> <em>pathtracer.cpp</em>.  Inside the ray tracer class everything begins with the method <code>Pathtracer::raytrace_pixel()</code> in <i class="icon-file"> </i> <em>pathtracer.cpp</em>.  This method computes the value of the specified pixel in the output image.</li>
<li>The camera is defined in the <code>Camera</code> class in <i class="icon-file"> </i> <em>camera.cpp</em>.  You will need to modify <code>Camera::generate_ray()</code> in Part 1 of the assignment to generate the camera rays that are sent out into the scene.</li>
<li>Scene objects (e.g., triangles and spheres) are instances of the <code>Primitive</code> interface defined in <i class="icon-file"> </i> <em>static_scene/Primitive.h</em>.  You will need to implement the <code>Primitive::intersect()</code> method for both triangles and spheres.</li>
<li>Lights implement the <code>Light</code> interface defined in  <i class="icon-file"> </i> <em>static_scene/Light.h</em>.  The initial starter code has working implementations of directional lights and constant hemispherical lights.</li>
<li>Light energy is represented by instances of the <code>Spectrum</code>
 class.  While it's tempting, we encourage you to avoid thinking of 
spectrums as colors -- think of them as a measurement of energy over 
many wavelengths.  Although our current implementation only represents 
spectrums by red, green, and blue components (much like the RGB 
representations of color you've used previously in this class), this 
abstraction makes it possible to consider other implementations of 
spectrum in the future.  Spectrums can be converted into colors using 
the <code>Spectrum::toColor()</code> method.</li>
<li>A major portion of the first half of the assignment concerns 
implementing a bounding volume hierarchy (BVH) that accelerates 
ray-scene intersection queries.  The implementation of the BVH will be 
located in <i class="icon-file"> </i> <em>bvh.cpp/.h</em>.  Note that a BVH is also an instance of the <code>Primitive</code> interface (A BVH is a scene primitive that itself contains other primitives.)</li>
</ul>

<p>Please refer to the inline comments (or the Doxygen documentation) for further details.</p>

<h3>Task 1: Generating Camera Rays</h3>

<p>"Camera rays" emanate from the camera and measure the amount of scene
 radiance that reaches a point on the camera's sensor plane.  (Given a 
point on the virtual sensor plane, there is a corresponding camera ray 
that is traced into the scene.)</p>

<p>Take a look at <code>Pathtracer::raytrace_pixel()</code> in <i class="icon-file"> </i> <em>pathtracer.cpp</em>.
  The job of this function is to compute the amount of energy arriving 
at this pixel of the image. Conveniently, we've given you a function <code>Pathtracer::trace_ray(r)</code> that provides a measurement of incoming scene radiance along the direction given by ray <code>r</code>.</p>

<p>When the number of samples per pixel is 1, you should sample incoming radiance at the <strong>center of each pixel</strong> by constructing a ray <code>r</code> that begins at this sensor location and travels through the camera's pinhole.   Once you have computed this ray, then call <code>Pathtracer::trace_ray(r)</code> to get the energy deposited in the pixel.</p>

<p><strong>Step 1:</strong> Given the width(<em>frameBuffer.w</em>) and height(<em>frameBuffer.h</em>)
 of the screen, and point in screen space, compute the corresponding 
coordinates of the point in normalized ([0-1]x[0x1]) screen space in <code>Pathtracer::raytrace_pixel()</code>.  Pass these coordinates to the camera via <code>Camera::generate_ray()</code> in <i class="icon-file"> </i> <em>camera.cpp</em>.</p>

<p><strong>Step 2:</strong> Implement <code>Camera::generate_ray()</code>. This function should return a ray <strong>in world space</strong>
 that reaches the given sensor sample point.  We recommend that you 
compute this ray in camera space (where the camera pinhole is at the 
origin, the camera is looking down the -Z axis, and +Y is at the top of 
the screen.)  Note that the camera maintains camera-space-to-world space
 transform <code>c2w</code> that will be handy.</p>

<p><strong>Step 3:</strong> Your implementation of <code>Pathtracer::raytrace_pixel()</code> must support supersampling (more than one sample per pixel).  The member <code>Pathtracer::ns_aa</code>
 in the raytracer class gives the number of samples of scene radiance 
your ray tracer should take per pixel (a.k.a. the number of camera rays 
per pixel.  Note that <code>Pathtracer::gridSampler-&gt;get_sample()</code>  provides uniformly distributed random 2D points in the [0-1]^2 box (see the implementation in <i class="icon-file"> </i> <em>sampler.cpp</em>).</p>

<p><strong>Tips:</strong></p>

<ul>
<li><p>Since it'll be hard to know if you camera rays are correct until 
you implement primitive intersection, we recommend debugging your camera
 rays by checking what your implementation of <code>Camera::generate_ray()</code> does with rays at the center of the screen (0.5, 0.5) and at the corners of the image.</p></li>
<li><p>Before starting to write any code, go through the existing code and make sure you understand the camera model we are using.</p></li>
</ul>

<p><strong>Extra credit ideas:</strong></p>

<ul>
<li>Modify the implementation of the camera to simulate a camera with a 
finite aperture (rather than a pinhole camera).  This will allow your 
ray tracer to simulate the effect of defocus blur.</li>
<li>Write your own <code>Sampler2D</code> implementation that generates samples with improved distribution.  Some examples include:

<ul>
<li>Jittered Sampling</li>
<li>Multi-jittered sampling</li>
<li>N-Rooks (Latin Hypercube) sampling</li>
<li>Sobol sequence sampling</li>
<li>Halton sequence sampling</li>
<li>Hammersley sequence sampling</li>
</ul></li>
</ul>

<h3>Task 2: Intersecting Triangles and Spheres</h3>

<p>Now that your ray tracer generates camera rays, you need to implement
 ray-primitive intersection routines for the two primitives in the 
starter code: triangles and spheres.  This handout will discuss the 
requirements of intersecting primitives in terms of triangles.</p>

<p>The <code>Primitive</code> interface contains two types of intersection routines:</p>

<ul>
<li><p><code>bool Triangle::intersect(const Ray&amp; r)</code> returns true/false depending on whether ray <code>r</code> hits the triangle.</p></li>
<li><p><code>bool Triangle::intersect(const Ray&amp; r, Intersection *isect)</code> returns true/false depending on whether ray <code>r</code> hits the triangle, but also populates an <code>Intersection</code> structure with information describing the surface at the point of the hit.</p></li>
</ul>

<p>You will need to implement both of these routines. Correctly doing so requires you to understand the fields in the <code>Ray</code> structure defined in <i class="icon-file"> </i> <em>ray.h</em>.</p>

<ul>
<li><code>Ray.o</code> represents the 3D point of origin of the ray</li>
<li><code>Ray.d</code> represents the 3D direction of the ray (this direction will be normalized)</li>
<li><code>Ray.min_t</code> and <code>Ray.max_t</code> correspond to the minimum and maximum points on the ray.  That is, intersections that lie outside the  <code>Ray.min_t</code> and <code>Ray.max_t</code> range <strong>should not</strong> be considered valid intersections with the primitive.</li>
</ul>

<p>There are also two additional fields in the <code>Ray</code> structure that can be helpful in accelerating your intersection computations with bounding boxes (see the <code>BBox</code> class in <i class="icon-file"> </i> <em>bbox.h</em>).  You may or may not find these precomputed values helpful in your computations.</p>

<ul>
<li><code>Ray.inv_d</code> is a vector holding (1/x, 1/d.y, 1/d.z)</li>
<li><code>Ray.sin[3]</code> hold indicators of the sign of each component of the ray's direction.</li>
</ul>

<p>One important detail of the <code>Ray</code> structure is that <code>min_t</code> and <code>max_t</code> are <code>mutable</code> fields of the <code>Ray</code>.  This means that these fields can be modified by constant member functions such as <code>Triangle::Intersect()</code>.  When finding the first intersection of a ray and the scene, you almost certainly want to update the ray's <code>max_t</code>
 value after finding hits with scene geometry.  By bounding the ray as 
tightly as possible, your ray tracer will be able to avoid unnecessary 
tests with scene geometry that is known to not be able to result in a 
closest hit, resulting in higher performance.</p>

<p><strong>Step 1: Intersecting Triangles</strong></p>

<p>While faster implementations are possible, we recommend you implement
 ray-triangle intersection using the method described in the <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/acceleration/slide_004">lecture slides</a>. Further details of implementing this method efficiently are given in <a href="http://15462.courses.cs.cmu.edu/fall2015/article/15">these notes</a>.</p>

<p>There are two important details you should be aware of about intersection:</p>

<ul>
<li><p>When finding the first-hit intersection with a triangle, you need to fill in the <code>Intersection</code> structure with details of the hit.  The structure should be initialized with:</p>

<ul>
<li><code>t</code>: the ray's t-value of the hit point</li>
<li><code>n</code>: the normal of the surface at the hit point.  This 
normal should be the interpolated normal (obtained via interpolation of 
the per-vertex normals according to the barycentric coordinates of the 
hit point)</li>
<li><code>primitive</code>: a pointer to the primitive  that was hit</li>
<li><code>bsdf</code>: a pointer to the surface brdf at the hit point (obtained via <code>mesh-&gt;get_bsdf()</code>)</li>
</ul></li>
<li><p>When intersection occurs with the back-face of a triangle (the 
side of the triangle opposite the direction of the normal) you should <strong>return the normal of triangle pointing away from the side of the triangle that was hit.</strong></p></li>
<li><p>If you need to distinguish back-face-hit and front-face-hit in 
your implementation, you might consider adding a flag(e.g. bool 
is_back_hit) to the 'Intersection' structure.</p></li>
</ul>

<p>Once you've successfully implemented triangle intersection, you will 
be able to render many of the scenes in the scenes directory (<i class="icon-folder"> </i> <em>/dae</em>)).  However, your ray tracer will be <strong>very slow!</strong></p>

<p><strong>Step 2: Intersecting Spheres</strong></p>

<p>Please also implement the intersection routines for the <code>Sphere</code> class in  <i class="icon-file"> </i> <em>sphere.cpp</em>.  Remember that your intersection tests should respect the ray's <code>min_t</code> and <code>max_t</code> values.</p>

<h3>Task 3: Implementing a Bounding Volume Hierarchy (BVH)</h3>

<p>In this task you will implement a bounding volume hierarchy that 
accelerates ray-scene intersection.  All of this work will be in the <code>BVHAccel</code> class in <i class="icon-file"> </i> <em>bvh.cpp</em>.</p>

<p>The starter code constructs a valid BVH, but it is a trivial BVH with a single node containing all scene primitives.  A <code>BVHNode</code> has the following fields:</p>

<ul>
<li><code>BBox bb</code>: the bounding box of the node  (bounds all primitives in the subtree rooted by this node)</li>
<li><code>int start</code>:  start index of primitives in the BVH's primitive array</li>
<li><code>size_t range</code>:   range of index in the primitive list (number of primitives in the subtree rooted by the node)</li>
<li><code>BVHNode* l</code>:     left child node</li>
<li><code>BVHNode* r</code>:     right child node</li>
</ul>

<p>The <code>BVHAccel</code> class maintains an array of all primitives in the BVH (<code>primitives</code>).  The fields <code>start</code> and <code>range</code> in the <code>BVHNode</code> refer the range of contained primitives in this array.</p>

<p><strong>Step 1:</strong> Your job is to construct a BVH using the <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/acceleration/slide_024">Surface Area Heuristic</a> discussed in class.  Tree construction should occur when the <code>BVHAccel</code> object is constructed.</p>

<p>We have implemented a number of tools to help you debug the BVH.  Press the <kbd>V</kbd>
 key to enter BVH visualization mode.  This mode allows you to directly 
visualize a BVH as shown below.  The current BVH node is highlighted in 
red.  Primitives in the left and right subtrees of the current BVH node 
are rendered in different colors.  <strong>Press the <kbd>LEFT</kbd> or <kbd>RIGHT</kbd> keys to descend to child nodes of the mesh. Press <kbd>UP</kbd></strong> to move the parent of the current node.</p>

<p><img src="DeveloperManual_files/cow_bvh.png" alt="BVH Vis"></p>

<p>Another view showing the contents of a lower node in the BVH:</p>

<p><img src="DeveloperManual_files/cow_bvh_2.png" alt="BVH Vis"></p>

<p><strong>Step 2:</strong> Implement the ray-BVH intersection routines required by the <code>Primitive</code>
 interface.  You may wish to consider the node visit order optimizations
 we discussed in class.  Once complete, your renderer should be able to 
render all of the test scenes in a reasonable amount of time.</p>

<h3>Task 4: Implementing Shadow Rays</h3>

<p>In this task you will modify <code>Pathtracer::trace_ray()</code> to implement accurate shadows.</p>

<p>Currently <code>trace_ray</code> computes the following:</p>

<ul>
<li>It computes the intersection of ray <code>r</code> with the scene.</li>
<li>It computes the amount of light arriving at the hit point <code>hit_p</code> (the irradiance at the hit point) by integrating radiance from all scene light sources.</li>
<li>It computes the radiance reflected from the <code>hit_p</code> in the direction of <code>-r</code>. (The amount of reflected light is based on the brdf of the surface at the hit point.)</li>
</ul>

<p>Shadows occur when another scene object blocks light emitted from scene light sources towards the hit point (<code>hit_p</code>).
  Fortunately, determining whether or not a ray of light from a light 
source to the hit point is occluded by another object is easy given a 
working ray tracer (which you have at this point!).  <strong>You simply want to know whether a ray originating from the hit point (<code>p_hit</code>), and traveling towards the light source (<code>dir_to_light</code>) hits any scene geometry before reaching the light (note, the light's distance from the hit point is given by <code>dist_to_light</code>).</strong></p>

<p>Your job is to implement the logic needed to compute whether <code>hit_p</code> is in shadow with respect to the current light source sample.  Below are a few tips:</p>

<ul>
<li>A common ray tracing pitfall is for the "shadow ray" shot into the scene to accidentally hit the same triangle as <code>r</code>
 (the surface is erroneously determined to be occluded because the 
shadow ray is determined to hit the surface!).  We recommend that you 
make sure the origin of the shadow ray is offset from the surface to 
avoid these erroneous "self-intersections".  For example, <code>o</code> = <code>p_hit + epsilon * dir_to_light</code>  (note: <code>EPS_D</code> is defined for this purpose).</li>
<li>You will find it useful to debug your shadow code using the <code>DirectionalLight</code> since it produces hard shadows that are easy to reason about.</li>
</ul>

<p>At this point you should be able to render very striking images. For 
example, here is the Stanford Dragon model rendered with both a 
directional light and a hemispherical light.</p>

<p><img src="DeveloperManual_files/shadow_directional.png" alt="Shadow directional"></p>

<p><img src="DeveloperManual_files/shadow_hemisphere.png" alt="Shadow directional"></p>

<h3>Task 5: Adding Path Tracing</h3>

<p><strong>A few notes before getting started:</strong></p>

<p>The new release of the starter code for tasks 5-7 makes a few changes
 and improvements to the original starter code of the assignment:</p>

<ul>
<li><p>The <code>BRDF</code> class has been renamed <code>BSDF</code> 
(for "bidirectional scattering distribution function") to indicate that 
the class is now responsible for computing both light that is reflected 
from the surface, but also light that is refracted as it is transmitted 
through the surface.  Implementations reside in <i class="icon-file"> </i> <em>bsdf.cpp/h</em>.</p></li>
<li><p>Rather than use a single hardcoded light source in your <code>Pathtracer::trace_ray()</code> lights are now defined as part of the scene description file.</p></li>
</ul>

<p>You should change your implementation of the reflectance estimate due to direct lighting in <code>Pathtracer::trace_ray()</code>  to iterate over the list of scene light sources using the following code:</p>

<p><code>for (SceneLight* light : scene-&gt;lights) {
    /// do work here...
}</code></p>

<ul>
<li><code>PathTracer::raytrace_pixel(size_t x, size_t y)</code> now returns a <code>Spectrum</code> for the pixel (it doesn't directly update the output image).  The update is now handled in <code>PathTracer::raytrace_tile()</code> and is included in the starter code.</li>
</ul>

<hr>

<p>In this task you will modify your ray tracer to add support for 
indirect illumination.  We wish for you to implement the path tracing 
algorithm that terminates ray paths using Russian Roulette, as discussed
 in class.  Recommend that you restructure the code in <code>Pathtracer::trace_ray()</code> as follows:</p>

<p>```
Pathtracer::trace_ray() {
  if (surface hit) {
       //
       // compute reflectance due to direct lighting only
       //
       for each light:
          accumulate reflectance contribution due to light</p>

<pre class="prettyprint"><code><span class="pln">   </span><span class="com">//</span><span class="pln">
   </span><span class="com">// add reflectance due to indirect illumination</span><span class="pln">
   </span><span class="com">//</span><span class="pln">
   randomly </span><span class="kwd">select</span><span class="pln"> a </span><span class="kwd">new</span><span class="pln"> ray direction </span><span class="pun">(</span><span class="pln">it may be
   reflection </span><span class="kwd">or</span><span class="pln"> transmittence ray depending on
   surface type </span><span class="pun">--</span><span class="pln"> see BSDF</span><span class="pun">::</span><span class="pln">sample_f</span><span class="pun">()</span><span class="pln">

   potentially kill path </span><span class="pun">(</span><span class="kwd">using</span><span class="pln"> </span><span class="typ">Russian</span><span class="pln"> roulette</span><span class="pun">)</span><span class="pln">

   evaluate weighted reflectance contribution due
   to light </span><span class="kwd">from</span><span class="pln"> </span><span class="kwd">this</span><span class="pln"> direction</span></code></pre>

<p>}
}
```</p>

<p>As a warmup for the next task, implement <code>BSDF::sample_f</code> for diffuse surfaces (<code>DiffuseBSDF:sample_f</code>). The implementation of <code>DiffuseBSDF::f</code>
 is already provided to you. After correctly implementing diffuse BSDF 
and path tracing, your renderer should be able to make a beautifully lit
 picture of the Cornell Box with:</p>

<p><code>./scotty3d -s 1024 -m 2 -t 8 ../dae/sky/CBspheres_lambertian.dae</code>
 <img src="DeveloperManual_files/cornell_lambertian.png" alt="Cornell Box Lambertian"></p>

<p>Note the time-quality tradeoff here. With these commandline 
arguments, your path tracer will be running with 8 worker threads at a 
sample rate of 256 camera rays per pixel, with a max ray depth of 4. 
This will produce an image with relatively high quality but will take 
quite some time to render. Rendering a high quality image will take a 
very long time as indicated by the image sequence below, so start 
testing your path tracer early!</p>

<p><img src="DeveloperManual_files/spheres.png" alt="Time-Quality Tradeoff "></p>

<p>Here are a few tips:</p>

<ul>
<li><p>The termination probability of paths can be determined based on the <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/globalillum/slide_044">overall throughput</a> of the path (you'll likely need to add a field to the <code>Ray</code> structure to implement this) or based on the value of the BSDF given <code>wo</code> and <code>wi</code>
 in the current step.  Keep in mind that delta function BRDFs can take 
on values greater than one, so clamping termination probabilities 
derived from BRDF values to 1 is wise.</p></li>
<li><p>To convert a <code>Spectrum</code> to a termination probability, we recommend you use the luminance (overall brightness) of the Spectrum, which is available via <code>Spectrum::illum()</code></p></li>
<li><p>We've given you some <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/globalillum/slide_047">pretty good notes</a> on how to do this part of the assignment, but it can still be tricky to get correct.</p></li>
</ul>

<h3>Task 6: Adding New Materials</h3>

<p>Now that you have implemented the ability to sample more complex 
light paths, it's finally time to add support for more types of 
materials (other than the fully Lambertian material provided to you in 
the starter code).  In this task you will add support for two types of 
materials: a perfect mirror and glass (a material featuring both 
specular reflection and transmittance).</p>

<p>To get started take a look at the <code>BSDF</code> interface in <i class="icon-file"> </i> <em>bsdf.cpp</em>.  There are a number of key methods you should understand:</p>

<ul>
<li><code>BSDF::f(wo,wi)</code> evaluates the distribution function for a given pair of directions.</li>
<li><code>BSDF::sample_f(const Vector3D&amp; wo, Vector3D* wi, float* pdf)</code> generates a random sample <code>wo</code>
 (which may be a reflection direction or a refracted transmitted light 
direction). The method returns the value of the distribution function 
for the pair of directions, and the pdf for the selected sample <code>wi</code>.</li>
</ul>

<p>There are also two helper functions in the BSDF class that you will need to implement:</p>

<ul>
<li><p><code>BSDF::reflect(w0, ...)</code> returns a direction <code>wi</code> that is the <strong>perfect specular reflection direction</strong> corresponding to <code>wi</code> (reflection of w0 about the normal, which in the surface coordinate space is [0,0,1]).  More detail about specular reflection <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/reflection/slide_028">is here</a>.</p></li>
<li><p><code>BSDF::refract(w0, ...)</code> returns the ray that results from refracting the ray <code>w0</code>  about the surface according to <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/reflection/slide_032">Snell's Law</a>.  The surface's index of refraction is given by the argument <code>ior</code>.  Your implementation should assume that if the ray <code>w0</code> is <strong>entering the surface</strong> (that is, if <code>cos(w0,N) &gt; 0</code>) then the ray is currently in vacuum (index of refraction = 1.0).  If <code>cos(w0,N) &lt; 0</code> then your code should assume the ray is leaving the surface and entering vacuum. <strong>In the case of total internal reflection, the method should return <code>false</code>.</strong></p></li>
</ul>

<p><strong>What you need to do:</strong></p>

<ol>
<li><p>Implement the class <code>MirrorBSDF</code> which represents a  material with perfect specular reflection (a perfect mirror).  You should Implement <code>MirrorBSDF::f()</code>, <code>MirrorBSFD::sample_f()</code>, and <code>BSDF::reflect()</code>.  <strong>(Hint: what should the pdf computed by <code>MirrorBSFD::sample_f()</code> be?  What should the reflectance function f() be?)</strong></p></li>
<li><p>Implement the class  <code>GlassBSDF</code> which is a glass-like material that both reflects light and transmit light.  As discussed <a href="http://15462.courses.cs.cmu.edu/fall2015/lecture/reflection/slide_035">in class</a> the fraction of light that is reflected and transmitted through glass is given by the <strong>dielectric Fresnel equations</strong>, which are <a href="http://15462.courses.cs.cmu.edu/fall2015/article/15">documented in detail here</a>.  Specifically your implementation should:</p>

<ul>
<li><code>Implement BSDF::refract()</code> to add support for refracted ray paths.</li>
<li>Use the Fresnel equations to compute the fraction of reflected light
 and the fraction of transmitted light. Your implementation of</li>
<li>Implement <code>GlassBSDF::sample_f()</code>.  Your implementation 
should use the Fresnel equations to compute the fraction of reflected 
light and the fraction of transmitted light.  The returned ray sample 
should be either a reflection ray or a refracted ray, with the 
probability of which type of ray to use for the current path 
proportional to the Fresnel reflectance. (e.g., If the Fresnel 
reflectance is 0.9, then you should generate a reflection ray 90% of the
 time. <strong>What should the pdf be in this case?</strong>)</li>
<li>You should read <a href="http://15462.courses.cs.cmu.edu/fall2015/article/15">the provided notes</a> on the Fresnel equations as well as on how to compute a transmittance BRDF.</li>
</ul></li>
</ol>

<p>When you are done, you will be able to render images like these:</p>

<p><img src="DeveloperManual_files/cornell_classic.png" alt="Cornell box spheres 256"></p>

<h3>Task 7: Infinite Environment Lighting</h3>

<p>The final task of this assignment will be to implement a new type of 
light source: an infinite environment light.  An environment light is a 
light that supplies incident radiance (really, the light intensity 
dPhi/dOmega) from all directions on the sphere.  The source is thought 
to be "infinitely far away", and is representative of realistic lighting
 environments in the real world: as a result, rendering using 
environment lighting can be quite striking.</p>

<p>The intensity of incoming light from each direction is defined by a texture map parameterized by phi and theta, as shown below.</p>

<p><img src="DeveloperManual_files/envmap_figure.jpg" alt="Environment map"></p>

<p>In this task you need to implement the <code>EnvironmentLight::sample_L()</code> method in <i class="icon-file"> </i> <em>static_scene/environment_light.cpp</em>.
  You'll start with uniform direction sampling to get things working, 
and then move to a more advanced implementation that uses <strong>importance sampling</strong> to significantly reduce variance in rendered images.</p>

<p><strong>Step one: uniform sampling</strong></p>

<p>To get things working, your first implementation of <code>EnvironmentLight::sample_L()</code> will be quite simple.  You should generate a random direction on the sphere (<strong>with uniform (1/4pi) probability with respect to solid angle</strong>), convert this direction to coordinates (phi, theta) and then look up the appropriate radiance value in the texture map using <strong>bilinear interpolation</strong> (note: we recommend you begin with bilinear interpolation to keep things simple.)</p>

<p>You an designate rendering to use a particular environment map using the <code>-e</code> commandline parameter:  (e.g., <code>-e ../exr/grace.exr</code> )</p>

<p>Since high dynamic range environment maps can be large files, we have
 not included them in the starter code repo.  You can download a set of 
environment maps <a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/asst3_images/asst3_exr_archive.zip">from this link</a>.</p>

<p><strong>Tips:</strong></p>

<ul>
<li>You must write your own code to uniformly sample the sphere.</li>
<li><code>envMap-&gt;data</code> contains the pixels of the environment map</li>
<li>The size of the environment texture is given by <code>envMap-&gt;w</code> and <code>envMap-&gt;h</code>.</li>
</ul>

<p><strong>Step two: importance sampling the environment map</strong></p>

<p>Much like light in the real world, most of the energy provided by an 
environment light source is concentrated in the directions toward bright
 light sources. <strong>Therefore, it makes sense to bias selection of 
sampled directions towards the directions for which incoming radiance is
 the greatest.</strong>  In this final task you will implement an 
importance sampling scheme for environment lights.  For environment 
lights with large variation in incoming light intensities, good 
importance sampling will significantly improve the quality of 
renderings.</p>

<p>The basic idea is that you will assign a probability to each pixel in
 the environment map based on the total flux passing through the solid 
angle it represents.  We've written up a <a href="http://15462.courses.cs.cmu.edu/fall2015/article/15">detailed set of notes for you here</a> (see "Task 7 notes").</p>

<p><strong>Here are a few tips:</strong></p>

<ul>
<li>When computing areas corresponding to a pixel, use the value of theta at the pixel centers.</li>
<li>We recommend precomputing the joint distributions p(phi, theta) and marginal distributions p(theta) in the constructor of <code>EnvironmentLight</code> and storing the resulting values in fields of the class.</li>
<li><code>Spectrum::illum()</code> returns the luminance (brightness) of
 a Spectrum.  The probability of a pixel should be proportional to the 
product of its luminance and the solid angle it subtends.</li>
<li><code>std::binary_search</code> is your friend. Documentation <a href="http://en.cppreference.com/w/cpp/algorithm/binary_search">is here</a>.</li>
</ul></div>




</div>

<hr size="1">

<div class="footer">
     Copyright 2016 Carnegie Mellon University
</div>


</div>  <!-- end of content_container (defined in header.php) -->
</div>  <!-- end main_container (defined in header.php) -->





<div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px none; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px none; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: italic; font-size-adjust: none; font-family: MathJax_Math,sans-serif;"></div></div></body></html>