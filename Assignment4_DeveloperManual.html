<!doctype html>
<html>
<head>
<link rel="icon" href="http://15462.courses.cs.cmu.edu/fall2016/assets/images/favicon/dragon.png" type="image/png">
<title>Assignment 4 Developer Manual : Computer Graphics : 15-462/662 Spring 2017</title>

<script src="http://use.edgefonts.net/open-sans:n3,i3,n4,i4,n6,i6,n7,i7,n8,i8.js"></script>
<script src="http://use.edgefonts.net/open-sans-condensed:n3,i3,n7.js"></script>

<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/jquery/1.8.3/jquery.min.js"></script>
<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/jquery/timeago/jquery.timeago.js"></script>
<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/jquery/cookie/jquery.cookie.js"></script>

<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/codemirror-3.0/lib/codemirror.js"></script>
<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/codemirror-3.0/mode/markdown/markdown.js"></script>

<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  skipStartupTypeset: true,
  showProcessingMessages: false,
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>


<link rel="stylesheet" type="text/css" href=" http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/codemirror-3.0/lib/codemirror.css">

<script src="http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/google-code-prettify/prettify.js"></script>
<link rel="stylesheet" type="text/css" href=" http://15462.courses.cs.cmu.edu/fall2016/assets/third_party/google-code-prettify/prettify.css">

<!-- NOTE(kayvonf): place at end to override 3rd party tools -->
<link rel="stylesheet" type="text/css" href=" http://15462.courses.cs.cmu.edu/fall2016/assets/css/main.css">

<script type="text/javascript">
var edit_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_edit_comment";
var delete_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_delete_comment";
var archive_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_archive_comment";
var add_private_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_private_comment";
var add_instructor_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_instructor_comment";
var add_comment_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_add_comment";
var comment_vote_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_comment_vote";
var toggle_subscribe_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_toggle_subscribe";
var prompt_students_url = "http://15462.courses.cs.cmu.edu/fall2016/comments/ajax_prompt_students";
var keep_alive_url = "http://15462.courses.cs.cmu.edu/fall2016/keep_alive";
</script>

<script type="text/javascript" src="http://15462.courses.cs.cmu.edu/fall2016/assets/js/main.js"></script>
<script type="text/javascript" src="http://15462.courses.cs.cmu.edu/fall2016/assets/js/comments.js"></script>

</head>
<body>

<div id="modal_overlay"></div>

<div class="main_container">

<div class="topbar">
<div class="topbar_left"><a href="http://cs.cmu.edu/~15462">[Home]</a></div>
</div>

<div class="content_container">

<!-- end of header -->






<div class="article_container">

<div class="common_title title">Assignment 4 Developer Manual</div>

<hr size="1">


<div class="markdown article-content">
<p><img src="http://15462.courses.cs.cmu.edu/fall2016content/Scotty3D/images/Scotty3DLogo.svg" alt="Scotty3DLogo" /></p>

<h2>Overview</h2>

<p>This document describes the internal data structures and algorithms that comprise the Scotty3D codebase, focusing mainly on core functionality (e.g., meshing and ray tracing).  Limited documentation of the graphical user interface (GUI) is available via comments in the source itself (though this information is not needed for assignments).</p>

<h2>Animator</h2>

<h2>Task 1 - Spline Interpolation</h2>

<p>As we discussed in class, data points in time can be interpolated by constructing an approximating piecewise polynomial or spline. In this assignment you will implement a particular kind of spline, called a Catmull-Rom spline. A Catmull-Rom spline is a piecewise cubic spline defined purely in terms of the points it interpolates. It is a popular choice in real animation systems, because the animator does not need to define additional data like tangents, etc. (However, your code may still need to numerically evaluate these tangents after the fact; more on this point later.) All of the methods relevant to spline interpolation can be found in <code>spline.h</code> with implementations in <code>spline.inl</code>.</p>

<h3>Task 1a - Hermite Curve over the Unit Interval</h3>

<p>Recall that a cubic polynomial is a function of the form</p>

<p>$$p(t) = at^3 + bt^2 + ct + d$$</p>

<p>where $a, b, c$, and $d$ are fixed coefficients. However, there are many different ways of specifying a cubic polynomial. In particular, rather than specifying the coefficients directly, we can specify the endpoints and tangents we wish to interpolate. This construction is called the "Hermite form" of the polynomial. In particular, the Hermite form is given by</p>

<p>$$p(t) = h_{00}(t)p_0 + h_{10}(t)m_0 + h_{01}(t)p_1 + h_{11}(t)m_1$$</p>

<p>where $p_0,p_1$ are the endpoint positions, $m_0,m_1$ are the endpoint tangents, and $h_{ij}$ are the Hermite bases</p>

<p>$$h_{00}(t) = 2t^3 - 3t^2 + 1$$</p>

<p>$$h_{10}(t) = t^3 - 2t^2 + t$$</p>

<p>$$h_{01}(t) = -2t^3 + 3t^2$$</p>

<p>$$h_{11}(t) = t^3 - t^2$$</p>

<p>Your first task is to implement the method <code>Spline::cubicSplineUnitInterval()</code>, which evaluates a spline defined over the time interval $[0,1]$ given a pair of endpoints and tangents at endpoints. Optionally, the user can also specify that they want one of the time derivatives of the spline (1st or 2nd derivative), which will be needed for our dynamics calculations.</p>

<p>Your basic strategy for implementing this routine should be:</p>

<ul>
<li>Evaluate the time, its square, and its cube. (For readability, you may want to make a local copy </li>
<li>Using these values, as well as the position and tangent values, compute the four basis functions $h_{00}, h_{01}, h_{10},$ and $h_{11}$ of a cubic polynomial in Hermite form. Or, if the user has requested the nth derivative, evaluate the nth derivative of each of the bases.</li>
<li>Finally, combine the endpoint and tangent data using the evaluated bases, and return the result.</li>
</ul>

<p>Notice that this function is templated on a type T. In C++, a templated class can operate on data of a variable type. In the case of a spline, for instance, we want to be able to interpolate all sorts of data: angles, vectors, colors, etc. So it wouldn't make sense to rewrite our spline class once for each of these types; instead, we use templates. In terms of implementation, your code will look no different than if you were operating on a basic type (e.g., doubles). However, the compiler will complain if you try to interpolate a type for which interpolation doesn't make sense! For instance, if you tried to interpolate <code>Skeleton</code> objects, the compiler would likely complain that there is no definition for the sum of two skeletons (via a + operator). In general, our spline interpolation will only make sense for data that comes from a vector space, since we need to add T values and take scalar multiples.</p>

<h3>Task 1B: Evaluation of a Catmull-Rom spline</h3>

<p>Using the routine from part 1A, you will now implement the method <code>Spline::evaluate()</code> which evaluates a general Catmull-Rom spline (and possibly one of its derivatives) at the specified time. Since we now know how to interpolate a pair of endpoints and tangents, the only task remaining is to find the interval closest to the query time, and evaluate its endpoints and tangents.</p>

<p>The basic idea behind Catmull-Rom is that for a given time t, we first find the four closest knots at times</p>

<p>$$t_0 &lt; t_1 \leq t &lt; t_2 &lt; t_3$$</p>

<p>We then use t1 and t2 as the endpoints of our cubic "piece," and for tangents we use the values</p>

<p>$$m_1 = ( p_2 - p_0 ) / (t_2 - t_0)$$</p>

<p>$$m_2 = ( p_3 - p_1 ) / (t_3 - t_1)$$</p>

<p>In other words, a reasonable guess for the tangent is given by the difference between neighboring points. (See the Wikipedia and our course slides for more details.)</p>

<div >
<img src="http://15462.courses.cs.cmu.edu/fall2016content/article_images/26_1.jpg" alt="Catmull-Rom Spline Interpolation"/>
</div>

<p>This scheme works great if we have two well-defined knots on either side of the query time t. But what happens if we get a query time near the beginning or end of the spline? Or what if the spline contains fewer than four knots? We still have to somehow come up with a reasonable definition for the positions and tangents of the curve at these times. For this assignment, your Catmull-Rom spline interpolation should satisfy the following properties:</p>

<ul>
<li>If there are no knots at all in the spline, interpolation should return the default value for the interpolated type. This value can be computed by simply calling the constructor for the type: T(). For instance, if the spline is interpolating Vector3D objects, then the default value will be $(0,0,0)$.</li>
<li>If there is only one knot in the spline, interpolation should always return the value of that knot (independent of the time). In other words, we simply have a constant interpolant. (What, therefore, should we return for the 1st and 2nd derivatives?)</li>
<li>If the query time is less than or equal to the initial knot, return the initial knot's value. (What do derivatives look like in this region?)</li>
<li>If the query time is greater than or equal to the final knot, return the final knot's value. (What do derivatives look like in this region?)</li>
</ul>

<p>Once we have two or more knots, interpolation can be handled using general-purpose code. In particular, we can adopt the following "mirroring" strategy to obtain the four knots used in our computation:</p>

<ul>
<li>Any query time between the first and last knot will have at least one knot "to the left" $(k_1)$ and one "to the right" $(k_2)$.</li>
<li>Suppose we don't have a knot "two to the left" $(k_0)$. Then we will define a "virtual" knot $k_0 = k_1 - (k_2-k_1)$. In other words, we will "mirror" the difference be observe between $k_1$ and $k_2$ to the other side of $k_1$.</li>
<li>Likewise, if we don't have a knot "two to the left" of $t (k_3)$, then we will "mirror" the difference to get a "virtual" knot $k_3 = k_2 + (k_2-k_1)$.</li>
<li>At this point, we have four valid knot values (whether "real" or "virtual"), and can compute our tangents and positions as usual.</li>
<li>These values are then handed off to our subroutine that computes cubic interpolation over the unit interval.</li>
</ul>

<p>An important thing to keep in mind is that <code>Spline::cubicSplineUnitInterval()</code> assumes that the time value t is between 0 and 1, whereas the distance between two knots on our Catmull-Rom spline can be arbitrary. Therefore, when calling this subroutine you will have to normalize t such that it is between 0 and 1, i.e., you will have to divide by the length of the current interval over which you are interpolating. You should think very carefully about how this normalization affects the value and derivatives computed by the subroutine, in comparison to the values and derivatives we want to return.</p>

<p>Internally, a Spline object stores its data in an STL map that maps knot times to knot values. A nice thing about an STL map is that it automatically keeps knots in sorted order. Therefore, we can quickly access the knot closest to a given time using the method <code>map::upper_bound()</code>, which returns an iterator to knot with the smallest time greater than the given query time (you can find out more about this method via online documentation for the Standard Template Library).</p>

<h3>Using the splines</h3>

<p>Once you have splines implemented, you should be able to move entire objects around the scene at different points on the timeline, and all aspects of it should be smoothly interpolated (e.g. position, rotation and scale).</p>

<h2>Task 2 - Skeleton Kinematics</h2>

<p>A <code>Skeleton</code> is what we use to drive our animation. You can think of them like the set of bones we have in our own bodies and joints that connect these bones. For convenience, we have merged the bones and joints into the <code>Joint</code> class which holds the orientation of the joint relative to its parent in its <code>rotation</code>, and <code>axis</code> representing the direction and length of the bone with respect to its parent <code>Joint</code>. Each <code>Mesh</code> has an associated <code>Skeleton</code> class which holds a rooted tree of <code>Joint</code>s, where each <code>Joint</code> can have an arbitrary number of children.</p>

<p>All of our joints are ball <code>Joint</code>s which have a set of 3 rotations around the $x$, $y$, and $z$ axes, called <em>Euler angles</em>. Whenever you deal with angles in this way, a fixed order of operations must be enforced, otherwise the same set of angles will not represent the same rotation. In order to get the full rotational transformation matrix, $R$, we can create individual rotation matrices around the $X$, $Y$, and $Z$ axes, which we call $R_x$, $R_y$, and $R_z$ respectively. The particular order of operations that we adopted for this assignment is that $R := R_x * R_y * R_z$.</p>

<h3>Task 2a - Forward Kinematics</h3>

<p>When a joint's parent is rotated, that transformation should be propagated down to all of its children. In the diagram below, $c_0$ is the parent of $c_1$ and $c_1$ is the parent of $c_2$. When a translation of $x_0$ and rotation of $\theta_0$ is applied to $c_0$, all of the descendants are affected by this transformation as well. Then, $c_1$ is rotated by $\theta_1$ which affects itself and $c_2$. Finally, when rotation of $\theta_2$ is applied to $c_2$, it only affects itself because it has no children.</p>

<div >
<img src="http://15462.courses.cs.cmu.edu/fall2016content/article_images/26_2.jpg" alt="Forward Kinematics"/>
</div>

<p>You need to implement these routines in <code>dynamic_scene/joint.cpp</code> for forward kinematics.</p>

<ul>
<li>Joint::getTransformation()<br />
Returns the transformation up to the base of this joint (end of its parent joint). <code>Joint</code> is a child class of <code>SceneObject</code> which has its own version of <code>getTransformation()</code> that you can use by calling <code>SceneObject::getTransformation()</code>. As explained above, a joint's transformation is accumulated as you traverse the hierarchy of joints. You should traverse upwards from this joint's parent all the way up to the root joint and accumulate their transformations. Also, make sure to apply the mesh's transformation at the end, accessible with <code>skeleton-&gt;mesh-&gt;getTransformation()</code>.</li>
<li>Joint::getBasePosInWorld()<br />
Returns the base position of the joint in world coordinate frame.</li>
<li>Joint::getEndPosInWorld()<br />
Returns the end position of the joint in world coordinate frame.</li>
</ul>

<h3>Task 2b - Inverse Kinematics</h3>

<h4>Single Target IK</h4>

<p>Now that we have a logical way to move joints around, we can implement Inverse Kinematics, which will move the joints around in order to reach a target point. There are a few different ways we can do this, but for this assignment we'll implement an iterative method called gradient descent in order to find the minimum of a function. For a function $f: \mathbb{R}^n \to \mathbb{R}$, we'll have the update scheme:</p>

<p>$$X_{k+1} = X_k - \tau \nabla f$$</p>

<p>Where $\tau$ is a small timestep. For this task, we'll be using gradient descent to find the minimum of the cost function:</p>

<p>$$f(\theta(t)) = \frac{1}{2}|p(\theta(t)) - q|^2$$</p>

<p>Where $p(\theta(t))$ is the position in world space of the target joint, and $q$ is the position in world space of the target point.</p>

<p>More specifically, we'll be using a technique called Jacobian Transpose, which relies on the assumption that:</p>

<p>$$\nabla_\theta f \approx \alpha J_\theta^T (p(\theta) - q)$$</p>

<p>Where:</p>

<ul>
<li>$\theta$ (n x 1) is the function $\theta(t) = (\theta_1(t),\ldots,\theta_n(t))$, where $\theta_i(t)$ is the angle of joint $i$ around the axis of rotation</li>
<li>$\alpha$ is a constant</li>
<li>$J_\theta$ (3 x n) is the Jacobian of $\theta$</li>
</ul>

<p>Note that here $n$ refers to the number of joints in the skeleton. Although in reality this can be reduced to just the number of joints between the target joint and the root, inclusive, because all joints not on that path should stay where they are, so their columns in $J_\theta$ will be 0. So $n$ can just be the number of joints between the target and the root, inclusive. Additionally note that since this will get multiplied by $\tau$ anyways, you can ignore the value of $\alpha$, and just consider the timestep as $\tau_2 = \tau * \alpha$.</p>

<p>Now we just need a way to calcluate the Jacobian of $\theta$. For this, we can use the fact that:</p>

<p>$$(J_\theta)_i = \vec{r} \times \vec{p}$$</p>

<p>Where:</p>

<ul>
<li>$J_i$ is the $i^{th}$ column of $(J_\theta)$</li>
<li>$\vec{r}$ is the axis of rotation</li>
<li>$\vec{p}$ is the vector from the base of joint $i$ to the end point of the target joint</li>
</ul>

<p>For a more in-depth derivation of Jacobian transpose (and a look into other inverse kinematics algorithms), please check out <a href="http://web.eecs.umich.edu/~ocj/courses/autorob/autorob_11_ik_jacobian.pdf">this presentation</a>. (Pages 61-69 in particular)</p>

<p>Now, all of this will work for updating the angle along a single axis, but we have 3 axes to deal with. Luckily, extending it to 3 dimensions isn't very difficult, we just need to update the angle along each axis independently.</p>

<h4>Multi-Target</h4>

<p>We'll extend this so we can have multiple targets, which will then use the function to minimize:</p>

<p>$$f(\theta(t)) = \frac{1}{2}\sum_i |p_i(\theta(t)) - q_i|^2$$</p>

<p>which is a simple extension actually. Since each term is independent and added together, we can get the gradient of this new cost function just by summing the gradients of each of the constituent cost functions!</p>

<p>You should implement multi-target IK, which will take a <code>std::map</code> of <code>Joint</code>s and target points for that joint. Each joint can only have 1 target point.</p>

<p>In order to implement this, you should update <code>Joint::calculateAngleGradient</code> and <code>Skeleton::reachForTarget</code>. <code>Joint::calculateAngleGradient</code> should calculate the gradient of $\theta$ in the x,y, and z directions, and add them to <code>Joint::ikAngleGradient</code> for all relevant joints. <code>Skeleton::reachForTarget</code> should actually do the gradient descent calculations and update the angles of each joint, saving them with <code>Joint::setAngle</code>. In this function, you should probably use a very small timestep, but do several iterations of gradient descent in order to speed things up. For even faster and better results, you can also implement a variable timestep instead of just using a fixed one. Note also that the root joint should never be updated.</p>

<p>A key thing for this part is to <em>remember what coordinate frame you're in</em>, because if you calculate the gradients in the wrong coordinate frame or use the axis of rotation in the wrong coordinate frame your answers will come out very wrong!</p>

<h2>Task 3 - Linear Blend Skinning</h2>

<p>Now that we have a skeleton set up, we need to link the skeleton to the mesh in order to get the mesh to follow the movements of the skeleton. We will implement linear blend skinning in <code>Mesh::linearBlendSkinning()</code>.</p>

<h3>Task 3a Naive Linear Blend Skinning</h3>

<p>The easiest way to do this is to update each of mesh vertices' positions in relation to the bones (<code>Joint</code>s) in the skeleton. You should compute each vertex's position with respect to each joint <code>j</code> in the skeleton in <code>j</code>'s coordinate frame when no transformations have been applied to the skeleton (bind pose). Then, you should find where this vertex would end up with respect to joint <code>j</code> after all of the joints in the skeletons have been transformed if it were to have the same relative position in <code>j</code>'s coordinate frame. Also, for this vertex, you should find the closest point on joint <code>j</code>'s bone segment (<code>axis</code>) and store the distance to the closest point. Structure called <code>LBSInfo</code> has been defined for you in <code>dynamic_scene/mesh.h</code> to store these information. Now, you can compute the final position of the vertex by doing a weighted average with respect to the inverse distance (closer bones should have more influence on the position of the vertex).</p>

<p>Below we have an equation representation. $v_i$ is the new vertex position. $w_{ij}$ is the weight metric computed as the inverse of distance between vertex $i$ and closest point on joint $j$. $v_i^j$ is the vertex's position with respect to joint $j$ after joint's transformations has been applied.</p>

<p>$$v_{i} = \sum_{j}{w_{ij}v_i^j}$$</p>

<p>$$w_{ij} = \frac{\frac{1}{dist_{ij}}}{\sum_{j}{\frac{1}{dist_{ij}}}}$$</p>

<h3>Task 3b Linear Blend Skinning with Threshold</h3>

<p>After you implemented the method in Task 3a, you probably noticed that parts of the mesh that is very far away moves when you move a joint. In part 3b, we will implement a threshold to limit the volume that each joint affects. You should change your code such that when parameter <code>useCapsuleRadius</code> is true, you check the distance between the vertex and the closest point on the joint, and if it is more than the joint's capsuleRadius, you do not let that joint affect this vertex.</p>

<p><img src="http://15462.courses.cs.cmu.edu/fall2016content/article_images/26_5.jpg" width="700px" alt="Naive Linear Blend Skinning"/>
<center>Naive linear blend skinning affects other parts of the mesh, not just the leg. Also, the leg does not follow the joint exactly because other joints hold it back.</center></p>

<p><img src="http://15462.courses.cs.cmu.edu/fall2016content/article_images/26_6.jpg" width="700px" alt="Linear Blend Skinning with Threshold"/>
<center>Linear blend skinning with threshold allows us to better pose our characters.</center></p>

<h2>Task 4 - Physical Simulation</h2>

<p>The next task is to implement an integrator for the (undamped) wave equation across a mesh: 
 $$u'' = \Delta u$$</p>

<p>We've discussed in class how to calculate the Discrete Laplacian operator, via the <em>cotan</em>-formula:
 $$\Delta u = \frac{1}{2}\sum_j (\cot \alpha_{ij} + \cot \beta_{ij})(u_j - u_i)$$</p>

<div >
<img src="http://15462.courses.cs.cmu.edu/fall2016content/article_images/26_.jpg" alt="Laplacian On a Triangle Mesh"/>
</div>

<p>For this task, you should update <code>Vertex::Laplacian</code> in <code>halfedgeMesh.cpp</code> and <code>Mesh::forwardEuler</code> and <code>Mesh::symplecticEuler</code> in <code>dynamic_scene/mesh.cpp</code>, storing your calculated <code>u</code> value in <code>Vertex::offset</code> and the calculated <code>u'</code> value in <code>Vertex::velocity</code>. Be careful about when you update these quantities. Note that since forward Euler is defined to solve a single, first-order differential equation, solving a second-order one will require you to break it up into 2 first order equations and solve each of them with forward Euler.</p>

<p>The next task is to change your intergrators to solve the damped wave equation across a mesh:
  $$u'' = \Delta u - \lambda u'$$
Where we call $\lambda$ the <em>damping factor</em>, which can take on any value between 0 and 1. You'll notice here that a damping factor of 0 is identical to the undamped case.</p>

<p>Once you've implemented these integrators, you can switch between them with <code>F</code> and <code>S</code>, change the timestep with <code>-</code> and <code>=</code>, and the damping factor with <code>SHIFT/-</code> and <code>SHIFT/=</code>. Be aware that Forward Euler is not numerically stable, so if your solutions blow up then it's the expected behavior.</p>

<h2>Task 5 - Get Creative!</h2>

<p>Now that you have an awesome animation system, make an awesome animation! You have 2 options on how to render your animation, you can use <code>t</code> (or <code>T</code>) to save the video with rasterization, or <code>n</code> (or <code>N</code>) to save the video with your raytracer, either one is fine! Once you've rendered all the frames of your video, you can combine them into a video by using:</p>

<pre>
ffmpeg -r 60 -f image2 -s 800x600 -i ./Video_[TIME]_%4d.png -vcodec libx264 out.mp4
</pre>

<p>Where <code>[TIME]</code> should be replaced by the timestamp in each frame's filename (they should all be identical). If you don't have ffmpeg installed on your system, you can get it through most package managers, or you can <a href="https://ffmpeg.org/download.html">download it directly</a>, or use your own video creation program.</p>

<p>Have fun!</p></div>




</div>

<hr size="1">

<div class="footer">
     Copyright 2017 Carnegie Mellon University
</div>


</div>  <!-- end of content_container (defined in header.php) -->
</div>  <!-- end main_container (defined in header.php) -->


</body>
</html>


